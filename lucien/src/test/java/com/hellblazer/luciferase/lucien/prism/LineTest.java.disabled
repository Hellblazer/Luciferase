/*
 * Copyright (C) 2025 Hal Hildebrand. All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.luciferase.lucien.prism;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test suite for Line class.
 * 
 * Tests cover SFC properties, parent-child relationships, containment accuracy,
 * neighbor finding, boundary conditions, and performance characteristics.
 * 
 * @author hal.hildebrand
 */
class LineTest {
    
    @Test
    @DisplayName("Line construction validates parameters")
    void testLineConstruction() {
        // Valid construction
        var line = new Line(5, 10);
        assertEquals(5, line.getLevel());
        assertEquals(10, line.getCoordinate());
        
        // Invalid level
        assertThrows(IllegalArgumentException.class, () -> new Line(-1, 0));
        assertThrows(IllegalArgumentException.class, () -> new Line(22, 0));
        
        // Invalid coordinate
        assertThrows(IllegalArgumentException.class, () -> new Line(0, -1));
        assertThrows(IllegalArgumentException.class, () -> new Line(0, Line.MAX_COORDINATE + 1));
        
        // Coordinate too large for level
        assertThrows(IllegalArgumentException.class, () -> new Line(3, 16)); // max for level 3 is 7
    }
    
    @Test
    @DisplayName("fromWorldCoordinate creates correct line")
    void testFromWorldCoordinate() {
        // Test various world coordinates
        var line1 = Line.fromWorldCoordinate(0.0f, 0);
        assertEquals(0, line1.getLevel());
        assertEquals(0, line1.getCoordinate());
        
        var line2 = Line.fromWorldCoordinate(0.5f, 1);
        assertEquals(1, line2.getLevel());
        assertEquals(1, line2.getCoordinate());
        
        var line3 = Line.fromWorldCoordinate(0.25f, 2);
        assertEquals(2, line3.getLevel());
        assertEquals(1, line3.getCoordinate());
        
        var line4 = Line.fromWorldCoordinate(0.999f, 3);
        assertEquals(3, line4.getLevel());
        assertEquals(7, line4.getCoordinate()); // Should clamp to max valid
        
        // Invalid world coordinates
        assertThrows(IllegalArgumentException.class, () -> Line.fromWorldCoordinate(-0.1f, 0));
        assertThrows(IllegalArgumentException.class, () -> Line.fromWorldCoordinate(1.0f, 0));
    }
    
    @Test
    @DisplayName("consecutiveIndex provides correct SFC ordering")
    void testConsecutiveIndex() {
        // Level 0 should have index 0
        var root = new Line(0, 0);
        assertEquals(0, root.consecutiveIndex());
        
        // Level 1 should have indices 0,1
        var line1_0 = new Line(1, 0);
        var line1_1 = new Line(1, 1);
        assertEquals(0, line1_0.consecutiveIndex());
        assertEquals(1, line1_1.consecutiveIndex());
        
        // Level 2 should have indices 0,1,2,3
        var line2_0 = new Line(2, 0);
        var line2_1 = new Line(2, 1);
        var line2_2 = new Line(2, 2);
        var line2_3 = new Line(2, 3);
        assertEquals(0, line2_0.consecutiveIndex());
        assertEquals(1, line2_1.consecutiveIndex());
        assertEquals(2, line2_2.consecutiveIndex());
        assertEquals(3, line2_3.consecutiveIndex());
        
        // Test monotonicity - consecutive coordinates should have consecutive indices
        for (int level = 1; level <= 5; level++) {
            var maxCoord = 1 << level;
            for (int coord = 0; coord < maxCoord - 1; coord++) {
                var line1 = new Line(level, coord);
                var line2 = new Line(level, coord + 1);
                assertTrue(line1.consecutiveIndex() < line2.consecutiveIndex(),
                         String.format("SFC not monotonic at level %d: coord %d index %d >= coord %d index %d",
                                     level, coord, line1.consecutiveIndex(), coord + 1, line2.consecutiveIndex()));
            }
        }
    }
    
    @Test
    @DisplayName("Parent-child relationships are correct")
    void testParentChildRelationships() {
        // Root has no parent
        var root = new Line(0, 0);
        assertNull(root.parent());
        
        // Test parent computation
        var line = new Line(3, 5);
        var parent = line.parent();
        assertNotNull(parent);
        assertEquals(2, parent.getLevel());
        assertEquals(2, parent.getCoordinate()); // 5 >> 1 = 2
        
        // Test child computation
        var child0 = parent.child(0);
        var child1 = parent.child(1);
        assertEquals(3, child0.getLevel());
        assertEquals(3, child1.getLevel());
        assertEquals(4, child0.getCoordinate()); // (2 << 1) + 0 = 4
        assertEquals(5, child1.getCoordinate()); // (2 << 1) + 1 = 5
        
        // Test round-trip: child -> parent -> child
        assertEquals(line, child1);
        
        // Test parent -> child -> parent
        assertEquals(parent, child0.parent());
        assertEquals(parent, child1.parent());
        
        // Test child index computation
        assertEquals(0, child0.getChildIndex());
        assertEquals(1, child1.getChildIndex());
        assertEquals(-1, root.getChildIndex());
    }
    
    @Test
    @DisplayName("Containment testing works correctly")
    void testContainment() {
        // Root contains everything
        var root = new Line(0, 0);
        assertTrue(root.contains(0.0f));
        assertTrue(root.contains(0.5f));
        assertTrue(root.contains(0.999f));
        assertFalse(root.contains(-0.1f));
        assertFalse(root.contains(1.0f));
        
        // Level 1 segments
        var line1_0 = new Line(1, 0);
        var line1_1 = new Line(1, 1);
        assertTrue(line1_0.contains(0.0f));
        assertTrue(line1_0.contains(0.25f));
        assertTrue(line1_0.contains(0.499f));
        assertFalse(line1_0.contains(0.5f));  // Belongs to next segment
        
        assertTrue(line1_1.contains(0.5f));
        assertTrue(line1_1.contains(0.75f));
        assertTrue(line1_1.contains(0.999f));
        assertFalse(line1_1.contains(0.499f)); // Belongs to previous segment
        
        // Test precision at segment boundaries
        var line2_1 = new Line(2, 1);
        var range = line2_1.getWorldRange();
        assertTrue(line2_1.contains(range[0]));     // Start inclusive
        assertFalse(line2_1.contains(range[1]));    // End exclusive
    }
    
    @Test
    @DisplayName("Neighbor finding works correctly")
    void testNeighborFinding() {
        // Middle element has both neighbors
        var line = new Line(3, 4);
        var lowerNeighbor = line.neighbor(-1);
        var upperNeighbor = line.neighbor(1);
        
        assertNotNull(lowerNeighbor);
        assertNotNull(upperNeighbor);
        assertEquals(3, lowerNeighbor.getCoordinate());
        assertEquals(5, upperNeighbor.getCoordinate());
        
        // Boundary elements
        var firstLine = new Line(3, 0);
        var lastLine = new Line(3, 7); // Max for level 3
        
        assertNull(firstLine.neighbor(-1));  // No lower neighbor
        assertNotNull(firstLine.neighbor(1));
        
        assertNotNull(lastLine.neighbor(-1));
        assertNull(lastLine.neighbor(1));    // No upper neighbor
        
        // Invalid direction
        assertThrows(IllegalArgumentException.class, () -> line.neighbor(0));
        assertThrows(IllegalArgumentException.class, () -> line.neighbor(2));
    }
    
    @Test
    @DisplayName("World coordinate conversion is accurate")
    void testWorldCoordinateConversion() {
        // Test range computation
        var line = new Line(2, 1);
        var range = line.getWorldRange();
        assertEquals(0.25f, range[0], 1e-6f);
        assertEquals(0.5f, range[1], 1e-6f);
        
        // Test center computation
        var center = line.getCenterWorldCoordinate();
        assertEquals(0.375f, center, 1e-6f);
        
        // Test consistency with fromWorldCoordinate
        for (int level = 0; level <= 5; level++) {
            var maxCoord = 1 << level;
            for (int coord = 0; coord < maxCoord; coord++) {
                var originalLine = new Line(level, coord);
                var centerCoord = originalLine.getCenterWorldCoordinate();
                var reconstructedLine = Line.fromWorldCoordinate(centerCoord, level);
                assertEquals(originalLine, reconstructedLine,
                           String.format("Round-trip failed at level %d coord %d", level, coord));
            }
        }
    }
    
    @Test
    @DisplayName("Boundary conditions are handled correctly")
    void testBoundaryConditions() {
        // Maximum level
        var maxLevelLine = new Line(Line.MAX_LEVEL, 0);
        assertEquals(Line.MAX_LEVEL, maxLevelLine.getLevel());
        assertThrows(IllegalArgumentException.class, () -> maxLevelLine.child(0));
        
        // Maximum coordinates at various levels
        for (int level = 0; level <= 5; level++) {
            var maxCoord = (1 << level) - 1;
            var line = new Line(level, maxCoord);
            assertEquals(level, line.getLevel());
            assertEquals(maxCoord, line.getCoordinate());
            
            if (level < Line.MAX_LEVEL) {
                // Should be able to create children
                assertNotNull(line.child(0));
                assertNotNull(line.child(1));
            }
        }
        
        // Edge case: world coordinate exactly 1.0 should clamp
        var edgeLine = Line.fromWorldCoordinate(0.999999f, 3);
        assertEquals(7, edgeLine.getCoordinate()); // Should clamp to max valid
    }
    
    
    @Test
    @DisplayName("Equals and hashCode work correctly")
    void testEqualsAndHashCode() {
        var line1 = new Line(3, 5);
        var line2 = new Line(3, 5);
        var line3 = new Line(3, 6);
        var line4 = new Line(4, 5);
        
        // Equals
        assertEquals(line1, line2);
        assertNotEquals(line1, line3);
        assertNotEquals(line1, line4);
        assertNotEquals(line1, null);
        assertNotEquals(line1, "not a line");
        
        // Hash code
        assertEquals(line1.hashCode(), line2.hashCode());
        // Different objects should generally have different hash codes
        assertNotEquals(line1.hashCode(), line3.hashCode());
        assertNotEquals(line1.hashCode(), line4.hashCode());
        
        // Reflexivity, symmetry, transitivity
        assertEquals(line1, line1);
        assertEquals(line1.equals(line2), line2.equals(line1));
        
        var line2Copy = new Line(3, 5);
        assertTrue(line1.equals(line2) && line2.equals(line2Copy) && line1.equals(line2Copy));
    }
    
    @Test
    @DisplayName("String representation is informative")
    void testToString() {
        var line = new Line(3, 5);
        var str = line.toString();
        
        assertTrue(str.contains("Line"));
        assertTrue(str.contains("level=3"));
        assertTrue(str.contains("coord=5"));
        assertTrue(str.contains("center="));
        
        // Should be parseable information
        assertTrue(str.length() > 20);
        assertFalse(str.contains("null"));
    }
}