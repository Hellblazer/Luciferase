/*
 * Copyright (C) 2025 Hal Hildebrand. All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.luciferase.lucien.prism;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test suite for PrismGeometry class.
 * 
 * Tests cover volume computation, centroid calculation, point containment,
 * distance computation, coordinate transformations, vertex generation,
 * surface area calculation, and bounding box computation.
 * 
 * @author hal.hildebrand
 */
class PrismGeometryTest {
    
    private static final float EPSILON = 1e-6f;
    
    @Test
    @DisplayName("Volume computation is accurate for triangular prisms")
    void testVolumeComputation() {
        // Root prism should have volume = 0.5 (half unit cube)
        var root = PrismKey.createRoot();
        var rootVolume = PrismGeometry.computeVolume(root);
        assertEquals(0.5f, rootVolume, EPSILON);
        
        // Level 1 prisms should have 1/8 of root volume
        var level1Key = new PrismKey(new Triangle(1, 0, 0, 0, 0), new Line(1, 0));
        var level1Volume = PrismGeometry.computeVolume(level1Key);
        assertEquals(rootVolume / 8.0f, level1Volume, EPSILON);
        
        // Level 2 prisms should have 1/64 of root volume
        var level2Key = new PrismKey(new Triangle(2, 0, 1, 1, 0), new Line(2, 1));
        var level2Volume = PrismGeometry.computeVolume(level2Key);
        assertEquals(rootVolume / 64.0f, level2Volume, EPSILON);
        
        // Volume should decrease by factor of 8 per level
        for (int level = 0; level <= 3; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            var volume = PrismGeometry.computeVolume(key);
            var expectedVolume = 0.5f / Math.pow(8, level);
            assertEquals(expectedVolume, volume, EPSILON);
        }
    }
    
    @Test
    @DisplayName("Centroid computation produces correct center points")
    void testCentroidComputation() {
        // Root prism centroid should be at (1/3, 1/3, 1/2)
        var root = PrismKey.createRoot();
        var rootCentroid = PrismGeometry.computeCentroid(root);
        assertArrayEquals(new float[]{1.0f/3.0f, 1.0f/3.0f, 0.5f}, rootCentroid, EPSILON);
        
        // Level 1 prism (0,0,0) centroid
        var level1Key = new PrismKey(new Triangle(1, 0, 0, 0, 0), new Line(1, 0));
        var level1Centroid = PrismGeometry.computeCentroid(level1Key);
        assertEquals(3, level1Centroid.length);
        
        // X and Y should be 1/6 (base 0 + cellSize/3, cellSize = 0.5)
        assertEquals(1.0f/6.0f, level1Centroid[0], EPSILON);
        assertEquals(1.0f/6.0f, level1Centroid[1], EPSILON);
        assertEquals(0.25f, level1Centroid[2], EPSILON); // Z should be 1/4
        
        // Test centroid at different positions
        var level2Key = new PrismKey(new Triangle(2, 0, 2, 1, 0), new Line(2, 3));
        var level2Centroid = PrismGeometry.computeCentroid(level2Key);
        
        // Should be within the prism bounds
        var bounds = PrismGeometry.computeBoundingBox(level2Key);
        assertTrue(level2Centroid[0] >= bounds[0] && level2Centroid[0] <= bounds[3]);
        assertTrue(level2Centroid[1] >= bounds[1] && level2Centroid[1] <= bounds[4]);
        assertTrue(level2Centroid[2] >= bounds[2] && level2Centroid[2] <= bounds[5]);
        
        // Centroid should be inside the prism
        assertTrue(PrismGeometry.containsPoint(level2Key, level2Centroid[0], level2Centroid[1], level2Centroid[2]));
    }
    
    @Test
    @DisplayName("Point containment testing works correctly")
    void testPointContainment() {
        // Root prism contains points in triangular region
        var root = PrismKey.createRoot();
        
        // Origin should be contained
        assertTrue(PrismGeometry.containsPoint(root, 0.0f, 0.0f, 0.0f));
        
        // Points in triangular region should be contained
        assertTrue(PrismGeometry.containsPoint(root, 0.1f, 0.1f, 0.5f));
        assertTrue(PrismGeometry.containsPoint(root, 0.3f, 0.3f, 0.7f));
        assertTrue(PrismGeometry.containsPoint(root, 0.5f, 0.0f, 0.3f)); // On edge
        assertTrue(PrismGeometry.containsPoint(root, 0.0f, 0.5f, 0.3f)); // On edge
        
        // Points outside triangular region should not be contained
        assertFalse(PrismGeometry.containsPoint(root, 0.6f, 0.6f, 0.5f)); // x+y > 1
        assertFalse(PrismGeometry.containsPoint(root, 0.8f, 0.8f, 0.5f)); // x+y > 1
        
        // Points outside Z range
        assertFalse(PrismGeometry.containsPoint(root, 0.2f, 0.2f, -0.1f));
        assertFalse(PrismGeometry.containsPoint(root, 0.2f, 0.2f, 1.1f));
        
        // Points outside XY bounds
        assertFalse(PrismGeometry.containsPoint(root, -0.1f, 0.2f, 0.5f));
        assertFalse(PrismGeometry.containsPoint(root, 0.2f, -0.1f, 0.5f));
        assertFalse(PrismGeometry.containsPoint(root, 1.1f, 0.2f, 0.5f));
        assertFalse(PrismGeometry.containsPoint(root, 0.2f, 1.1f, 0.5f));
        
        // Test smaller prism
        var level2Key = new PrismKey(new Triangle(2, 0, 1, 1, 0), new Line(2, 2));
        var bounds = PrismGeometry.computeBoundingBox(level2Key);
        
        // Points within bounds and triangular region should be contained
        var midX = (bounds[0] + bounds[3]) / 2;
        var midY = (bounds[1] + bounds[4]) / 2;
        var midZ = (bounds[2] + bounds[5]) / 2;
        
        // Check if point satisfies triangular constraint
        var cellSize = 1.0f / (1 << level2Key.getLevel());
        var localX = midX - bounds[0];
        var localY = midY - bounds[1];
        
        if (localX + localY <= cellSize) {
            assertTrue(PrismGeometry.containsPoint(level2Key, midX, midY, midZ));
        }
    }
    
    @Test
    @DisplayName("Distance computation handles interior and exterior points")
    void testDistanceComputation() {
        var prism = new PrismKey(new Triangle(2, 0, 1, 1, 0), new Line(2, 1));
        var centroid = PrismGeometry.computeCentroid(prism);
        
        // Distance to centroid should be 0
        var distToCentroid = PrismGeometry.computeDistanceToPoint(prism, centroid[0], centroid[1], centroid[2]);
        assertEquals(0.0f, distToCentroid, EPSILON);
        
        // Distance to any interior point should be 0
        if (PrismGeometry.containsPoint(prism, 0.3f, 0.3f, 0.3f)) {
            var distToInterior = PrismGeometry.computeDistanceToPoint(prism, 0.3f, 0.3f, 0.3f);
            assertEquals(0.0f, distToInterior, EPSILON);
        }
        
        // Distance to exterior points should be positive
        var bounds = PrismGeometry.computeBoundingBox(prism);
        var farX = bounds[3] + 1.0f; // Far to the right
        var farY = bounds[4] + 1.0f; // Far up
        var farZ = bounds[5] + 1.0f; // Far above
        
        var distToFar = PrismGeometry.computeDistanceToPoint(prism, farX, farY, farZ);
        assertTrue(distToFar > 0.0f);
        
        // Distance should increase as we move further away
        var dist1 = PrismGeometry.computeDistanceToPoint(prism, centroid[0] + 0.1f, centroid[1], centroid[2]);
        var dist2 = PrismGeometry.computeDistanceToPoint(prism, centroid[0] + 0.2f, centroid[1], centroid[2]);
        assertTrue(dist2 > dist1);
        
        // Test distance to origin from various prisms
        var distances = new float[4];
        for (int level = 0; level <= 3; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            distances[level] = PrismGeometry.computeDistanceToPoint(key, 0.0f, 0.0f, 0.0f);
        }
        
        // Origin should be contained in all level-0 prisms at (0,0,0)
        assertEquals(0.0f, distances[0], EPSILON);
    }
    
    @Test
    @DisplayName("Vertex generation produces correct triangular prism vertices")
    void testVertexGeneration() {
        // Root prism vertices
        var root = PrismKey.createRoot();
        var rootVertices = PrismGeometry.getVertices(root);
        
        assertEquals(6, rootVertices.length);
        
        // Check that we have expected vertices for right triangular prism
        // Bottom triangle: (0,0,0), (1,0,0), (0,1,0)
        // Top triangle: (0,0,1), (1,0,1), (0,1,1)
        var expectedVertices = new float[][] {
            {0, 0, 0}, {1, 0, 0}, {0, 1, 0},  // Bottom triangle
            {0, 0, 1}, {1, 0, 1}, {0, 1, 1}   // Top triangle
        };
        
        for (int i = 0; i < 6; i++) {
            assertEquals(expectedVertices[i][0], rootVertices[i].x, EPSILON);
            assertEquals(expectedVertices[i][1], rootVertices[i].y, EPSILON);
            assertEquals(expectedVertices[i][2], rootVertices[i].z, EPSILON);
        }
        
        // Test smaller prism
        var level1Key = new PrismKey(new Triangle(1, 0, 1, 0, 0), new Line(1, 1));
        var level1Vertices = PrismGeometry.getVertices(level1Key);
        
        assertEquals(6, level1Vertices.length);
        
        // All vertices should be within [0,1]³
        for (var vertex : level1Vertices) {
            assertTrue(vertex.x >= 0.0f && vertex.x <= 1.0f);
            assertTrue(vertex.y >= 0.0f && vertex.y <= 1.0f);
            assertTrue(vertex.z >= 0.0f && vertex.z <= 1.0f);
        }
        
        // Bottom and top triangles should have same X,Y coordinates but different Z
        for (int i = 0; i < 3; i++) {
            assertEquals(level1Vertices[i].x, level1Vertices[i+3].x, EPSILON);
            assertEquals(level1Vertices[i].y, level1Vertices[i+3].y, EPSILON);
            assertTrue(level1Vertices[i+3].z > level1Vertices[i].z);
        }
    }
    
    @Test
    @DisplayName("Surface area computation includes all faces")
    void testSurfaceAreaComputation() {
        // Root prism surface area
        var root = PrismKey.createRoot();
        var rootSurfaceArea = PrismGeometry.computeSurfaceArea(root);
        
        // Expected: 2 triangles + 3 rectangles
        // Triangle area = 0.5 * 1 * 1 = 0.5
        // Rectangle areas = 1*1 + 1*1 + sqrt(2)*1 = 2 + sqrt(2)
        // Total = 2*0.5 + 2 + sqrt(2) = 1 + 2 + sqrt(2) = 3 + sqrt(2)
        var expectedArea = 3.0f + (float)Math.sqrt(2.0);
        assertEquals(expectedArea, rootSurfaceArea, EPSILON);
        
        // Surface area should scale by 1/4 per level (area scales as length²)
        for (int level = 0; level <= 2; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            var surfaceArea = PrismGeometry.computeSurfaceArea(key);
            var expectedSurfaceArea = expectedArea / Math.pow(4, level);
            assertEquals(expectedSurfaceArea, surfaceArea, EPSILON * 10); // Slightly higher tolerance for sqrt(2)
        }
        
        // All surface areas should be positive
        for (int level = 0; level <= 3; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            var surfaceArea = PrismGeometry.computeSurfaceArea(key);
            assertTrue(surfaceArea > 0.0f);
        }
    }
    
    @Test
    @DisplayName("Coordinate transformations are bidirectional")
    void testCoordinateTransformations() {
        var prism = new PrismKey(new Triangle(2, 0, 1, 2, 0), new Line(2, 1));
        
        // Test local to world transformation
        var localCoords = new float[]{0.5f, 0.3f, 0.7f};
        var worldCoords = PrismGeometry.localToWorld(prism, localCoords[0], localCoords[1], localCoords[2]);
        
        assertEquals(3, worldCoords.length);
        
        // World coordinates should be within global bounds
        for (var coord : worldCoords) {
            assertTrue(coord >= 0.0f && coord <= 1.0f);
        }
        
        // Transform back to local coordinates
        var backToLocal = PrismGeometry.worldToLocal(prism, worldCoords[0], worldCoords[1], worldCoords[2]);
        
        assertNotNull(backToLocal);
        assertEquals(3, backToLocal.length);
        
        // Should recover original local coordinates
        assertArrayEquals(localCoords, backToLocal, EPSILON);
        
        // Test corner cases
        var corners = new float[][]{
            {0.0f, 0.0f, 0.0f},  // Origin corner
            {1.0f, 0.0f, 0.0f},  // X edge
            {0.0f, 1.0f, 0.0f},  // Y edge
            {0.0f, 0.0f, 1.0f},  // Z edge
            {0.5f, 0.5f, 0.5f}   // Center (if valid)
        };
        
        for (var corner : corners) {
            // Check if corner satisfies triangular constraint (x + y <= 1)
            if (corner[0] + corner[1] <= 1.0f) {
                var world = PrismGeometry.localToWorld(prism, corner[0], corner[1], corner[2]);
                var local = PrismGeometry.worldToLocal(prism, world[0], world[1], world[2]);
                
                if (local != null) {
                    assertArrayEquals(corner, local, EPSILON);
                }
            }
        }
        
        // Test transformation of points outside the prism
        var bounds = PrismGeometry.computeBoundingBox(prism);
        var outsidePoint = new float[]{bounds[3] + 0.1f, bounds[4] + 0.1f, bounds[5] + 0.1f};
        var outsideLocal = PrismGeometry.worldToLocal(prism, outsidePoint[0], outsidePoint[1], outsidePoint[2]);
        
        assertNull(outsideLocal); // Should return null for points outside
    }
    
    @Test
    @DisplayName("Bounding box computation is accurate")
    void testBoundingBoxComputation() {
        // Root prism bounding box should be [0,0,0,1,1,1]
        var root = PrismKey.createRoot();
        var rootBounds = PrismGeometry.computeBoundingBox(root);
        
        assertArrayEquals(new float[]{0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f}, rootBounds, EPSILON);
        
        // Test level 1 prism at (0,0,0)
        var level1Key = new PrismKey(new Triangle(1, 0, 0, 0, 0), new Line(1, 0));
        var level1Bounds = PrismGeometry.computeBoundingBox(level1Key);
        
        assertArrayEquals(new float[]{0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f}, level1Bounds, EPSILON);
        
        // Test level 2 prism at (2,1,3)
        var level2Key = new PrismKey(new Triangle(2, 0, 2, 1, 0), new Line(2, 3));
        var level2Bounds = PrismGeometry.computeBoundingBox(level2Key);
        
        var cellSize = 1.0f / 4.0f; // Level 2 cell size
        var expectedBounds = new float[]{
            2 * cellSize, 1 * cellSize, 3 * cellSize,  // min x,y,z
            3 * cellSize, 2 * cellSize, 4 * cellSize   // max x,y,z
        };
        
        assertArrayEquals(expectedBounds, level2Bounds, EPSILON);
        
        // Verify bounding box properties
        for (int level = 0; level <= 3; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            var bounds = PrismGeometry.computeBoundingBox(key);
            
            // Min coordinates should be <= max coordinates
            assertTrue(bounds[0] <= bounds[3]); // minX <= maxX
            assertTrue(bounds[1] <= bounds[4]); // minY <= maxY
            assertTrue(bounds[2] <= bounds[5]); // minZ <= maxZ
            
            // All coordinates should be in [0,1]
            for (var coord : bounds) {
                assertTrue(coord >= 0.0f && coord <= 1.0f);
            }
            
            // Centroid should be within bounding box
            var centroid = PrismGeometry.computeCentroid(key);
            assertTrue(centroid[0] >= bounds[0] && centroid[0] <= bounds[3]);
            assertTrue(centroid[1] >= bounds[1] && centroid[1] <= bounds[4]);
            assertTrue(centroid[2] >= bounds[2] && centroid[2] <= bounds[5]);
        }
    }
    
    @Test
    @DisplayName("Geometric calculations are consistent across levels")
    void testGeometricConsistency() {
        // Test that geometric properties scale correctly across levels
        var rootVolume = PrismGeometry.computeVolume(PrismKey.createRoot());
        var rootSurfaceArea = PrismGeometry.computeSurfaceArea(PrismKey.createRoot());
        
        for (int level = 1; level <= 3; level++) {
            var key = new PrismKey(new Triangle(level, 0, 0, 0, 0), new Line(level, 0));
            
            // Volume should scale as 1/8^level
            var volume = PrismGeometry.computeVolume(key);
            var expectedVolume = rootVolume / Math.pow(8, level);
            assertEquals(expectedVolume, volume, EPSILON);
            
            // Surface area should scale as 1/4^level
            var surfaceArea = PrismGeometry.computeSurfaceArea(key);
            var expectedSurfaceArea = rootSurfaceArea / Math.pow(4, level);
            assertEquals(expectedSurfaceArea, surfaceArea, EPSILON * 10);
            
            // Bounding box dimensions should scale as 1/2^level
            var bounds = PrismGeometry.computeBoundingBox(key);
            var width = bounds[3] - bounds[0];
            var height = bounds[4] - bounds[1];
            var depth = bounds[5] - bounds[2];
            
            var expectedSize = 1.0f / (1 << level);
            assertEquals(expectedSize, width, EPSILON);
            assertEquals(expectedSize, height, EPSILON);
            assertEquals(expectedSize, depth, EPSILON);
        }
    }
    
}