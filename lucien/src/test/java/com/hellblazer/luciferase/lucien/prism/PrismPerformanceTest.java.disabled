/*
 * Copyright (C) 2025 Hal Hildebrand. All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.luciferase.lucien.prism;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Performance tests for prism spatial index components.
 * 
 * These tests are separated from functional tests because they can be brittle
 * and depend on system load, CPU scheduling, JIT compilation, and other
 * environmental factors. They should be run separately and not block CI.
 * 
 * Run with: mvn test -Dgroups=performance
 * Exclude with: mvn test -DexcludedGroups=performance
 * 
 * @author hal.hildebrand
 */
@Tag("performance")
class PrismPerformanceTest {
    
    private static final int WARMUP_ITERATIONS = 1000;
    private static final int MEASUREMENT_ITERATIONS = 10000;
    
    @BeforeEach
    void warmUp() {
        // JIT warmup to get more consistent measurements
        var triangle = new Triangle(5, 0, 10, 5, 3);
        var line = new Line(5, 8);
        var prismKey = new PrismKey(triangle, line);
        
        for (int i = 0; i < WARMUP_ITERATIONS; i++) {
            triangle.consecutiveIndex();
            line.consecutiveIndex();
            prismKey.consecutiveIndex();
            PrismGeometry.computeVolume(prismKey);
        }
    }
    
    @Test
    @DisplayName("Triangle SFC computation performance")
    void testTriangleSFCPerformance() {
        var triangle = new Triangle(10, 1, 512, 256, 128);
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            triangle.consecutiveIndex();
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        // Log results but don't fail - these are informational
        System.out.printf("Triangle SFC computation: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 10µs per call even on slow systems
        assertTrue(avgTimeNs < 10_000, "Triangle SFC extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("Triangle parent/child operation performance")
    void testTriangleParentChildPerformance() {
        var triangle = new Triangle(10, 1, 512, 256, 128);
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            var parent = triangle.parent();
            if (parent != null) {
                parent.child(0);
            }
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Triangle parent/child operations: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 50µs per call even on slow systems
        assertTrue(avgTimeNs < 50_000, "Triangle parent/child extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("Line SFC computation performance")
    void testLineSFCPerformance() {
        var line = new Line(10, 512);
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            line.consecutiveIndex();
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Line SFC computation: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 1µs per call even on slow systems
        assertTrue(avgTimeNs < 1_000, "Line SFC extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("Line parent/child operation performance")
    void testLineParentChildPerformance() {
        var line = new Line(10, 512);
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            var parent = line.parent();
            if (parent != null) {
                parent.child(0);
            }
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Line parent/child operations: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 10µs per call even on slow systems
        assertTrue(avgTimeNs < 10_000, "Line parent/child extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("PrismGeometry volume computation performance")
    void testVolumeComputationPerformance() {
        var prism = new PrismKey(new Triangle(10, 1, 256, 128, 64), new Line(10, 512));
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            PrismGeometry.computeVolume(prism);
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Volume computation: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 5µs per call even on slow systems
        assertTrue(avgTimeNs < 5_000, "Volume computation extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("PrismGeometry centroid computation performance")
    void testCentroidComputationPerformance() {
        var prism = new PrismKey(new Triangle(10, 1, 256, 128, 64), new Line(10, 512));
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            PrismGeometry.computeCentroid(prism);
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Centroid computation: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 10µs per call even on slow systems
        assertTrue(avgTimeNs < 10_000, "Centroid computation extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("PrismGeometry point containment performance")
    void testPointContainmentPerformance() {
        var prism = new PrismKey(new Triangle(10, 1, 256, 128, 64), new Line(10, 512));
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            PrismGeometry.containsPoint(prism, 0.5f, 0.3f, 0.7f);
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Point containment: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 20µs per call even on slow systems
        assertTrue(avgTimeNs < 20_000, "Point containment extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("PrismGeometry distance computation performance")
    void testDistanceComputationPerformance() {
        var prism = new PrismKey(new Triangle(10, 1, 256, 128, 64), new Line(10, 512));
        
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            PrismGeometry.computeDistanceToPoint(prism, 0.5f, 0.3f, 0.7f);
        }
        var endTime = System.nanoTime();
        
        var avgTimeNs = (endTime - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Distance computation: %.1f ns per call%n", (double) avgTimeNs);
        
        // Sanity check - should be under 30µs per call even on slow systems
        assertTrue(avgTimeNs < 30_000, "Distance computation extremely slow: " + avgTimeNs + "ns per call");
    }
    
    @Test
    @DisplayName("Relative performance comparison")
    void testRelativePerformance() {
        var triangle = new Triangle(8, 0, 100, 50, 25);
        var line = new Line(8, 200);
        var prism = new PrismKey(triangle, line);
        
        // Measure line SFC (should be fastest)
        var startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            line.consecutiveIndex();
        }
        var lineTime = (System.nanoTime() - startTime) / MEASUREMENT_ITERATIONS;
        
        // Measure triangle SFC (should be slower)
        startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            triangle.consecutiveIndex();
        }
        var triangleTime = (System.nanoTime() - startTime) / MEASUREMENT_ITERATIONS;
        
        // Measure prism SFC (should be slowest)
        startTime = System.nanoTime();
        for (int i = 0; i < MEASUREMENT_ITERATIONS; i++) {
            prism.consecutiveIndex();
        }
        var prismTime = (System.nanoTime() - startTime) / MEASUREMENT_ITERATIONS;
        
        System.out.printf("Relative performance - Line: %.1fns, Triangle: %.1fns, Prism: %.1fns%n", 
                         (double) lineTime, (double) triangleTime, (double) prismTime);
        
        // Relative ordering check (allowing for measurement noise)
        assertTrue(lineTime <= triangleTime * 2, "Line should be faster than or comparable to triangle");
        assertTrue(triangleTime <= prismTime * 2, "Triangle should be faster than or comparable to prism");
        
        // Sanity check - all should be under 100µs
        assertTrue(lineTime < 100_000, "Line SFC too slow");
        assertTrue(triangleTime < 100_000, "Triangle SFC too slow");
        assertTrue(prismTime < 100_000, "Prism SFC too slow");
    }
}