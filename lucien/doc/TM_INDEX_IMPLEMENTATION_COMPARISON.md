# TM-Index Implementation Comparison: Tet vs TMIndex128Clean

## Overview

This document compares the TM-index encode/decode implementations between our current `Tet` class and the `TMIndex128Clean` reference implementation. Both implement the same tetrahedral space-filling curve index but with different design philosophies and optimizations.

## Key Differences

### 1. Architecture & Design

**TMIndex128Clean:**
- Pure algorithmic implementation focused on the TM-index encoding/decoding
- Self-contained with minimal dependencies
- Uses simple data structures (`TetId` record, `TMIndex128Bit` for storage)
- Clean separation between encode and decode operations

**Tet Implementation:**
- Integrated into a larger spatial indexing system
- Heavy use of caching infrastructure (`TetreeLevelCache`)
- Returns `TetreeKey` objects that include level information
- Optimized for repeated operations with multiple cache layers

### 2. Coordinate System & Bit Extraction

**TMIndex128Clean:**
```java
// Extracts bits from LSB to MSB (level 0 to level n-1)
int xBit = (tet.x >> level) & 1;
int yBit = (tet.y >> level) & 1;
int zBit = (tet.z >> level) & 1;
```

**Tet Implementation:**
```java
// Extracts bits from MSB to LSB (level n-1 down to level 0)
int bitPos = Constants.getMaxRefinementLevel() - 1 - i;
int xBit = (x >> bitPos) & 1;
int yBit = (y >> bitPos) & 1;
int zBit = (z >> bitPos) & 1;
```

**Critical Difference:** The bit extraction order is reversed! This is a fundamental difference that affects how the SFC index is built.

### 3. Type Sequence Computation

**TMIndex128Clean:**
```java
// Computes type sequence forward from root to current level
int currentType = 0;
for (int level = 1; level < tet.level; level++) {
    int bitPos = level - 1;
    int childIdx = ((tet.z >> bitPos) & 1) << 2 | 
                   ((tet.y >> bitPos) & 1) << 1 | 
                   ((tet.x >> bitPos) & 1);
    currentType = CHILD_TYPES[currentType][childIdx];
    types[level] = currentType;
}
```

**Tet Implementation:**
```java
// Attempts to use cached transitions, falls back to parent chain walk
// Walks backwards from current tetrahedron to root
Tet current = this;
while (current.l() > 1) {
    current = current.parent();
    ancestorTypes.addFirst(current.type());
}
```

**Key Differences:**
- TMIndex128Clean computes types algorithmically using a child type table
- Tet uses actual parent traversal or cached parent chains
- TMIndex128Clean is more efficient but requires knowing the full coordinate path
- Tet's approach works with incomplete information but is slower

### 4. Data Structures

**TMIndex128Clean:**
```java
// Simple records
record TetId(int x, int y, int z, int type, int level) {}
record TMIndex128Bit(long low, long high) {}
```

**Tet Implementation:**
```java
// Rich domain objects
record Tet(int x, int y, int z, byte l, byte type) {
    // Many methods for spatial operations
}
class TetreeKey implements SpatialKey<TetreeKey> {
    // Includes level, BigInteger fallback, comparison logic
}
```

### 5. Performance Optimizations

**TMIndex128Clean:**
- Direct bit manipulation
- No caching (pure computation)
- Minimal object allocation
- Optimized for bulk operations

**Tet Implementation:**
- Multiple cache layers (TetreeKey cache, parent chain cache, type transition cache)
- Lazy evaluation support
- Thread-local caching option
- Optimized for repeated queries in spatial index

### 6. Bit Packing Format

Both use the same 6-bit packing format:
```
[coord_bits(3)][type_bits(3)]
     z y x         t t t
```

However, the order these are stored differs:
- **TMIndex128Clean**: Level 0 at bits 0-5, Level 1 at bits 6-11, etc.
- **Tet**: Same storage order, but interprets the levels differently due to MSB-first extraction

### 7. Decode Implementation

**TMIndex128Clean:**
```java
// Rebuilds coordinates bit by bit from level 0 up
for (int i = 0; i < level; i++) {
    int sixBits = /* extract from appropriate position */;
    int coordBits = (sixBits >> 3) & 0x7;
    x |= (coordBits & 1) << i;
    y |= ((coordBits >> 1) & 1) << i;
    z |= ((coordBits >> 2) & 1) << i;
}
// Then recomputes final type by following the path
```

**Tet Implementation:**
```java
// Extracts all bits first, then reconstructs coordinates
for (int i = 0; i < maxBits; i++) {
    // Extract coordinate bits into arrays
}
// Then places bits at correct positions based on MAX_LEVEL
for (int i = 0; i < maxBits; i++) {
    int bitPos = Constants.getMaxRefinementLevel() - 1 - i;
    x |= (coordXBits[i] << bitPos);
}
```

## Critical Implementation Issues

### 1. Incompatible Bit Ordering
The most significant difference is the bit extraction order. This means:
- TM-indices generated by TMIndex128Clean are **not compatible** with those from Tet
- The same tetrahedron will have different TM-index values in each system
- This affects spatial locality properties of the SFC

### 2. Type Computation Differences
- TMIndex128Clean uses a consistent forward computation
- Tet uses actual parent relationships which may differ if the tetrahedron wasn't created through standard refinement

### 3. Coordinate Scaling
- Tet uses coordinates scaled to the full integer range (0 to 2^21)
- TMIndex128Clean works with grid coordinates (0 to 2^level - 1)

## Recommendations

1. **Standardize Bit Order**: Both implementations should use the same bit extraction order (recommend LSB to MSB as in TMIndex128Clean)

2. **Unify Type Computation**: Use the algorithmic approach from TMIndex128Clean for consistency and performance

3. **Document Coordinate System**: Clearly specify whether coordinates are grid-based or absolute

4. **Consider Compatibility Layer**: If both systems need to coexist, provide conversion utilities

5. **Performance Testing**: The caching in Tet may not provide benefits if the cache miss rate is high

## Conclusion

While both implementations achieve the same goal of encoding tetrahedral positions into a space-filling curve index, they use fundamentally different approaches:

- **TMIndex128Clean**: Clean, algorithmic, self-contained, efficient
- **Tet**: Feature-rich, cache-heavy, integrated with spatial index, flexible

The incompatible bit ordering means these implementations cannot interoperate without conversion. Any system using TM-indices must choose one approach and stick with it consistently.