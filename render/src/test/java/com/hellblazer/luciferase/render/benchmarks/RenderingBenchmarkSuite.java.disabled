package com.hellblazer.luciferase.render.benchmarks;

import com.hellblazer.luciferase.render.compression.DXTCompressor;
import com.hellblazer.luciferase.render.compression.SparseVoxelCompressor;
import com.hellblazer.luciferase.render.memory.GPUMemoryManager;
import com.hellblazer.luciferase.render.performance.RenderingProfiler;
import com.hellblazer.luciferase.render.testdata.TestDataGenerator;
import com.hellblazer.luciferase.render.voxel.pipeline.MeshVoxelizer;
import com.hellblazer.luciferase.render.webgpu.WebGPURenderBridge;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.vecmath.Point3f;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assumptions.assumeTrue;

/**
 * Comprehensive benchmarking suite for rendering pipeline performance.
 * Measures performance across different data sizes, resolutions, and configurations.
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class RenderingBenchmarkSuite {
    
    private static final Logger log = LoggerFactory.getLogger(RenderingBenchmarkSuite.class);
    
    private static WebGPURenderBridge renderBridge;
    private static GPUMemoryManager memoryManager;
    private static RenderingProfiler profiler;
    private static boolean gpuAvailable = false;
    
    // Benchmark results storage
    private static List<BenchmarkResult> results = new ArrayList<>();
    
    @BeforeAll
    static void setupBenchmarks() throws Exception {
        log.info("Setting up rendering benchmarks...");
        
        try {
            renderBridge = new WebGPURenderBridge();
            var initFuture = renderBridge.initialize();
            gpuAvailable = initFuture.get(10, TimeUnit.SECONDS);
            
            if (gpuAvailable) {
                var webgpuContext = new com.hellblazer.luciferase.render.voxel.gpu.WebGPUContext();
                var memConfig = new GPUMemoryManager.MemoryConfiguration();
                memoryManager = new GPUMemoryManager(webgpuContext, memConfig);
                profiler = new RenderingProfiler(memoryManager);
                log.info("GPU systems initialized for benchmarking");
            } else {
                log.warn("GPU not available - benchmarks will run in CPU mode only");
            }
        } catch (Exception e) {
            log.warn("GPU initialization failed: {}", e.getMessage());
            gpuAvailable = false;
        }
        
        // Initialize profiler in any case for CPU benchmarks
        if (profiler == null) {
            if (memoryManager == null) {
                // Create a dummy memory manager for CPU-only mode
                var webgpuContext = new com.hellblazer.luciferase.render.voxel.gpu.WebGPUContext();
                var memConfig = new GPUMemoryManager.MemoryConfiguration();
                memoryManager = new GPUMemoryManager(webgpuContext, memConfig);
            }
            profiler = new RenderingProfiler(memoryManager);
        }
    }
    
    @AfterAll
    static void cleanupBenchmarks() throws Exception {
        log.info("Cleaning up benchmarks...");
        
        if (profiler != null) {
            profiler.shutdown();
        }
        if (memoryManager != null) {
            memoryManager.shutdown();
        }
        if (renderBridge != null) {
            renderBridge.shutdown();
        }
        
        // Generate final benchmark report
        generateBenchmarkReport();
    }
    
    @Test
    @Order(1)
    void benchmarkTestDataGeneration() {
        log.info("=== Benchmark 1: Test Data Generation Performance ===");
        
        var sizes = new int[]{16, 32, 64, 128};
        
        for (var size : sizes) {
            // Benchmark cube generation
            long startTime = System.nanoTime();
            var cubeVertices = TestDataGenerator.generateCubeVertices(2.0f);
            long cubeTime = System.nanoTime() - startTime;
            
            // Benchmark sphere generation
            startTime = System.nanoTime();
            var sphereVertices = TestDataGenerator.generateSphereVertices(1.0f, 3);
            long sphereTime = System.nanoTime() - startTime;
            
            // Benchmark voxel data generation
            startTime = System.nanoTime();
            var voxelData = TestDataGenerator.generateTestVoxelData(size, 0.3f);
            long voxelTime = System.nanoTime() - startTime;
            
            // Benchmark octree data generation
            startTime = System.nanoTime();
            var octreeData = TestDataGenerator.generateTestOctreeData(5);
            long octreeTime = System.nanoTime() - startTime;
            
            results.add(new BenchmarkResult("Cube Generation", size, cubeTime / 1_000_000.0, 
                       cubeVertices.remaining() / 3, "vertices"));
            results.add(new BenchmarkResult("Sphere Generation", size, sphereTime / 1_000_000.0,
                       sphereVertices.remaining() / 3, "vertices"));
            results.add(new BenchmarkResult("Voxel Data Generation", size, voxelTime / 1_000_000.0,
                       voxelData.remaining(), "voxels"));
            results.add(new BenchmarkResult("Octree Data Generation", size, octreeTime / 1_000_000.0,
                       octreeData.remaining(), "bytes"));
            
            log.info("Size {}: Cube={:.2f}ms, Sphere={:.2f}ms, Voxel={:.2f}ms, Octree={:.2f}ms",
                    size, cubeTime / 1_000_000.0, sphereTime / 1_000_000.0,
                    voxelTime / 1_000_000.0, octreeTime / 1_000_000.0);
        }
    }
    
    @Test
    @Order(2)
    void benchmarkMeshVoxelization() {
        log.info("=== Benchmark 2: Mesh Voxelization Performance ===");
        
        var voxelResolutions = new int[]{64, 128, 256, 512};
        var sphereComplexities = new int[]{1, 2, 3}; // Subdivision levels
        
        for (var resolution : voxelResolutions) {
            for (var complexity : sphereComplexities) {
                var voxelizer = new MeshVoxelizer(resolution);
                var sphereVertices = TestDataGenerator.generateSphereVertices(1.0f, complexity);
                
                long startTime = System.nanoTime();
                var triangles = createTriangleList(sphereVertices);
                var voxelizedData = voxelizer.voxelize(triangles, resolution);
                long voxelizationTime = System.nanoTime() - startTime;
                
                var triangleCount = sphereVertices.remaining() / 9; // 3 vertices * 3 components per triangle
                var voxelsGenerated = voxelizedData.getActiveVoxelCount();
                
                results.add(new BenchmarkResult("Mesh Voxelization", resolution, 
                           voxelizationTime / 1_000_000.0, triangleCount, "triangles"));
                
                log.info("Resolution {}³, Complexity {}: {:.2f}ms, {} triangles -> {} voxels",
                        resolution, complexity, voxelizationTime / 1_000_000.0, 
                        triangleCount, voxelsGenerated);
            }
        }
    }
    
    @Test
    @Order(3)
    void benchmarkVoxelCompression() {
        log.info("=== Benchmark 3: Voxel Compression Performance ===");
        
        var compressor = new SparseVoxelCompressor();
        var resolutions = new int[]{32, 64, 128, 256};
        var fillRatios = new float[]{0.1f, 0.25f, 0.5f, 0.75f};
        
        for (var resolution : resolutions) {
            for (var fillRatio : fillRatios) {
                var voxelData = TestDataGenerator.generateTestVoxelData(resolution, fillRatio);
                var originalSize = voxelData.remaining();
                
                // Benchmark compression
                long startTime = System.nanoTime();
                var octreeNode = createOctreeNode(voxelData);
                var compressed = compressor.compress(octreeNode);
                long compressionTime = System.nanoTime() - startTime;
                
                // Benchmark decompression
                startTime = System.nanoTime();
                var decompressed = compressor.decompress(compressed);
                long decompressionTime = System.nanoTime() - startTime;
                
                var compressedSize = compressed.remaining();
                var compressionRatio = (double) originalSize / compressedSize;
                
                results.add(new BenchmarkResult("Voxel Compression", resolution,
                           compressionTime / 1_000_000.0, originalSize, "bytes"));
                results.add(new BenchmarkResult("Voxel Decompression", resolution,
                           decompressionTime / 1_000_000.0, compressedSize, "bytes"));
                
                log.info("{}³ @ {:.0%} fill: Compress={:.2f}ms, Decompress={:.2f}ms, Ratio={:.2f}x",
                        resolution, fillRatio, compressionTime / 1_000_000.0, 
                        decompressionTime / 1_000_000.0, compressionRatio);
            }
        }
    }
    
    @Test
    @Order(4)
    void benchmarkTextureCompression() {
        log.info("=== Benchmark 4: Texture Compression Performance ===");
        
        var compressor = new DXTCompressor();
        var textureSizes = new int[]{64, 128, 256, 512};
        
        for (var size : textureSizes) {
            // Generate test texture data
            var textureData = ByteBuffer.allocateDirect(size * size * 4);
            for (int i = 0; i < size * size; i++) {
                textureData.put((byte)(i % 256))     // R
                          .put((byte)((i * 2) % 256)) // G
                          .put((byte)((i * 3) % 256)) // B
                          .put((byte)255);             // A
            }
            textureData.flip();
            
            // Benchmark DXT1 compression
            var originalSize = textureData.remaining();
            long startTime = System.nanoTime();
            var dxt1Compressed = compressor.compress(textureData, size, size,
                                                    DXTCompressor.CompressionFormat.DXT1);
            long dxt1CompressTime = System.nanoTime() - startTime;
            
            // Benchmark DXT1 decompression
            startTime = System.nanoTime();
            var dxt1Decompressed = compressor.decompress(dxt1Compressed, size, size,
                                                         DXTCompressor.CompressionFormat.DXT1);
            long dxt1DecompressTime = System.nanoTime() - startTime;
            
            // Benchmark DXT5 compression
            textureData.rewind();
            startTime = System.nanoTime();
            var dxt5Compressed = compressor.compress(textureData, size, size,
                                                    DXTCompressor.CompressionFormat.DXT5);
            long dxt5CompressTime = System.nanoTime() - startTime;
            
            // Benchmark DXT5 decompression
            startTime = System.nanoTime();
            var dxt5Decompressed = compressor.decompress(dxt5Compressed, size, size,
                                                         DXTCompressor.CompressionFormat.DXT5);
            long dxt5DecompressTime = System.nanoTime() - startTime;
            
            results.add(new BenchmarkResult("DXT1 Compression", size,
                       dxt1CompressTime / 1_000_000.0, originalSize, "bytes"));
            results.add(new BenchmarkResult("DXT1 Decompression", size,
                       dxt1DecompressTime / 1_000_000.0, dxt1Compressed.remaining(), "bytes"));
            results.add(new BenchmarkResult("DXT5 Compression", size,
                       dxt5CompressTime / 1_000_000.0, originalSize, "bytes"));
            results.add(new BenchmarkResult("DXT5 Decompression", size,
                       dxt5DecompressTime / 1_000_000.0, dxt5Compressed.remaining(), "bytes"));
            
            log.info("{}x{} texture: DXT1 compress={:.2f}ms, decompress={:.2f}ms; " +
                    "DXT5 compress={:.2f}ms, decompress={:.2f}ms",
                    size, size, 
                    dxt1CompressTime / 1_000_000.0, dxt1DecompressTime / 1_000_000.0,
                    dxt5CompressTime / 1_000_000.0, dxt5DecompressTime / 1_000_000.0);
        }
    }
    
    @Test
    @Order(5)
    void benchmarkGPUMemoryOperations() {
        log.info("=== Benchmark 5: GPU Memory Operations ===");
        
        assumeTrue(gpuAvailable, "GPU not available - skipping GPU memory benchmarks");
        
        var bufferSizes = new long[]{1024, 4096, 16384, 65536, 262144, 1048576}; // 1KB to 1MB
        var iterations = 100;
        
        for (var bufferSize : bufferSizes) {
            var allocTimes = new ArrayList<Long>();
            var buffers = new ArrayList<AutoCloseable>();
            
            // Benchmark allocation
            for (int i = 0; i < iterations; i++) {
                long startTime = System.nanoTime();
                var bufferUsage = com.hellblazer.luciferase.render.voxel.gpu.WebGPUStubs.BufferUsage.STORAGE;
                var buffer = memoryManager.allocateBuffer(bufferSize, bufferUsage, "benchmark-buffer");
                long allocTime = System.nanoTime() - startTime;
                allocTimes.add(allocTime);
                if (buffer != null) buffers.add(buffer);
            }
            
            // Benchmark deallocation
            var deallocTimes = new ArrayList<Long>();
            for (var buffer : buffers) {
                long startTime = System.nanoTime();
                try {
                    buffer.close();
                } catch (Exception e) {
                    log.warn("Buffer close failed", e);
                }
                long deallocTime = System.nanoTime() - startTime;
                deallocTimes.add(deallocTime);
            }
            
            var avgAllocTime = allocTimes.stream().mapToLong(Long::longValue).average().orElse(0.0) / 1000.0; // μs
            var avgDeallocTime = deallocTimes.stream().mapToLong(Long::longValue).average().orElse(0.0) / 1000.0; // μs
            
            results.add(new BenchmarkResult("GPU Buffer Allocation", (int)(bufferSize / 1024),
                       avgAllocTime / 1000.0, bufferSize, "bytes"));
            results.add(new BenchmarkResult("GPU Buffer Deallocation", (int)(bufferSize / 1024),
                       avgDeallocTime / 1000.0, bufferSize, "bytes"));
            
            log.info("{}KB buffers: Alloc={:.2f}μs, Dealloc={:.2f}μs (avg over {} iterations)",
                    bufferSize / 1024, avgAllocTime, avgDeallocTime, iterations);
        }
    }
    
    @Test
    @Order(6)
    void benchmarkPipelineEnd2End() {
        log.info("=== Benchmark 6: End-to-End Pipeline Performance ===");
        
        var configurations = new PipelineConfiguration[]{
            new PipelineConfiguration("Small", 64, 0.2f, 2),
            new PipelineConfiguration("Medium", 128, 0.3f, 2), 
            new PipelineConfiguration("Large", 256, 0.4f, 3),
            new PipelineConfiguration("Extra Large", 512, 0.3f, 3)
        };
        
        for (var config : configurations) {
            log.info("Testing pipeline configuration: {}", config.name);
            
            var frameProfiler = profiler.startFrame(1);
            long overallStartTime = System.nanoTime();
            
            try {
                // Phase 1: Data generation
                frameProfiler.startPhase("Data Generation");
                long phaseStart = System.nanoTime();
                var meshVertices = TestDataGenerator.generateSphereVertices(1.0f, config.complexity);
                var voxelData = TestDataGenerator.generateTestVoxelData(config.resolution, config.fillRatio);
                long dataGenTime = System.nanoTime() - phaseStart;
                frameProfiler.endFrame();
                
                // Phase 2: Mesh voxelization
                frameProfiler.startPhase("Mesh Voxelization");
                phaseStart = System.nanoTime();
                var voxelizer = new MeshVoxelizer(config.resolution);
                var triangles = createTriangleList(meshVertices);
                var voxelizedMesh = voxelizer.voxelize(triangles, config.resolution);
                long voxelizationTime = System.nanoTime() - phaseStart;
                frameProfiler.endFrame();
                
                // Phase 3: Voxel compression
                frameProfiler.startPhase("Voxel Compression");
                phaseStart = System.nanoTime();
                var compressor = new SparseVoxelCompressor();
                var octreeNode = createOctreeNode(voxelData);
                var compressedVoxels = compressor.compress(octreeNode);
                long compressionTime = System.nanoTime() - phaseStart;
                frameProfiler.endFrame();
                
                // Phase 4: Texture operations (if applicable)
                frameProfiler.startPhase("Texture Processing");
                phaseStart = System.nanoTime();
                if (config.resolution >= 128) {
                    var textureCompressor = new DXTCompressor();
                    var textureData = ByteBuffer.allocateDirect(64 * 64 * 4);
                    // Fill with test pattern
                    for (int i = 0; i < 64 * 64; i++) {
                        textureData.put((byte)(i % 256))
                                  .put((byte)((i * 2) % 256))
                                  .put((byte)((i * 3) % 256))
                                  .put((byte)255);
                    }
                    textureData.flip();
                    var compressedTexture = textureCompressor.compressDXT5(textureData, 64, 64);
                }
                long textureTime = System.nanoTime() - phaseStart;
                frameProfiler.endFrame();
                
                long totalTime = System.nanoTime() - overallStartTime;
                
                results.add(new BenchmarkResult("End-to-End Pipeline", config.resolution,
                           totalTime / 1_000_000.0, meshVertices.remaining() / 9, "triangles"));
                
                log.info("{}: Total={:.2f}ms (DataGen={:.2f}ms, Voxelization={:.2f}ms, " +
                        "Compression={:.2f}ms, Texture={:.2f}ms)",
                        config.name, totalTime / 1_000_000.0, dataGenTime / 1_000_000.0,
                        voxelizationTime / 1_000_000.0, compressionTime / 1_000_000.0,
                        textureTime / 1_000_000.0);
                
            } finally {
                frameProfiler.endFrame();
            }
        }
    }
    
    @Test 
    @Order(7)
    void benchmarkMemoryUsage() {
        log.info("=== Benchmark 7: Memory Usage Analysis ===");
        
        Runtime runtime = Runtime.getRuntime();
        var initialMemory = runtime.totalMemory() - runtime.freeMemory();
        
        var resolutions = new int[]{64, 128, 256};
        
        for (var resolution : resolutions) {
            // Force garbage collection before measurement
            System.gc();
            Thread.yield();
            
            var beforeMemory = runtime.totalMemory() - runtime.freeMemory();
            
            // Allocate test data
            var voxelData = TestDataGenerator.generateTestVoxelData(resolution, 0.3f);
            var sphereVertices = TestDataGenerator.generateSphereVertices(1.0f, 3);
            var compressor = new SparseVoxelCompressor();
            var octreeNode = createOctreeNode(voxelData);
            var compressedData = compressor.compress(octreeNode);
            
            var afterMemory = runtime.totalMemory() - runtime.freeMemory();
            var memoryUsed = afterMemory - beforeMemory;
            
            results.add(new BenchmarkResult("Memory Usage", resolution,
                       memoryUsed / 1024.0 / 1024.0, resolution * resolution * resolution, "voxels"));
            
            log.info("Resolution {}³: {:.2f} MB memory used for {} voxels ({:.2f} bytes/voxel)",
                    resolution, memoryUsed / 1024.0 / 1024.0, resolution * resolution * resolution,
                    (double) memoryUsed / (resolution * resolution * resolution));
            
            // Clean up references
            voxelData = null;
            sphereVertices = null;
            compressedData = null;
            compressor = null;
        }
    }
    
    private static void generateBenchmarkReport() {
        log.info("\n" + "=".repeat(80));
        log.info("RENDERING BENCHMARK SUITE RESULTS");
        log.info("=".repeat(80));
        
        var categories = results.stream()
                               .map(r -> r.category)
                               .distinct()
                               .sorted()
                               .toList();
        
        for (var category : categories) {
            log.info("\n{} Results:", category);
            log.info("-".repeat(50));
            
            var categoryResults = results.stream()
                                        .filter(r -> r.category.equals(category))
                                        .toList();
            
            for (var result : categoryResults) {
                log.info("  Size {}: {:.3f}ms - {} {}", 
                        result.size, result.timeMs, result.dataCount, result.unit);
            }
            
            // Calculate statistics
            var times = categoryResults.stream().mapToDouble(r -> r.timeMs).toArray();
            if (times.length > 0) {
                var avgTime = java.util.Arrays.stream(times).average().orElse(0.0);
                var minTime = java.util.Arrays.stream(times).min().orElse(0.0);
                var maxTime = java.util.Arrays.stream(times).max().orElse(0.0);
                
                log.info("  Stats: avg={:.3f}ms, min={:.3f}ms, max={:.3f}ms", 
                        avgTime, minTime, maxTime);
            }
        }
        
        log.info("\n" + "=".repeat(80));
        log.info("Benchmark suite completed with {} results", results.size());
        log.info("=".repeat(80));
    }
    
    private static class BenchmarkResult {
        final String category;
        final int size;
        final double timeMs;
        final long dataCount;
        final String unit;
        
        BenchmarkResult(String category, int size, double timeMs, long dataCount, String unit) {
            this.category = category;
            this.size = size;
            this.timeMs = timeMs;
            this.dataCount = dataCount;
            this.unit = unit;
        }
    }
    
    private static class PipelineConfiguration {
        final String name;
        final int resolution;
        final float fillRatio;
        final int complexity;
        
        PipelineConfiguration(String name, int resolution, float fillRatio, int complexity) {
            this.name = name;
            this.resolution = resolution;
            this.fillRatio = fillRatio;
            this.complexity = complexity;
        }
    }
    
    // Helper methods
    private static List<MeshVoxelizer.Triangle> createTriangleList(FloatBuffer vertices) {
        var triangles = new ArrayList<MeshVoxelizer.Triangle>();
        vertices.rewind();
        
        while (vertices.remaining() >= 9) {
            var v0 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            var v1 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            var v2 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            triangles.add(new MeshVoxelizer.Triangle(v0, v1, v2, 0));
        }
        
        vertices.rewind();
        return triangles;
    }
    
    private static SparseVoxelCompressor.OctreeNode createOctreeNode(ByteBuffer voxelData) {
        // Create a simple octree node for testing
        var node = new SparseVoxelCompressor.OctreeNode(
            SparseVoxelCompressor.NodeType.BRANCH, 0);
        node.level = 0;
        node.childMask = 0xFF; // All children present
        node.leafMask = 0x00;  // No leaves
        
        // Add some sample data
        voxelData.rewind();
        int sampleSize = Math.min(voxelData.remaining(), 256);
        node.data = new byte[sampleSize];
        voxelData.get(node.data);
        voxelData.rewind();
        
        return node;
    }
}