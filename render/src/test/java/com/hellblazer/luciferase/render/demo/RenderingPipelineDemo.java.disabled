package com.hellblazer.luciferase.render.demo;

import com.hellblazer.luciferase.render.compression.DXTCompressor;
import com.hellblazer.luciferase.render.compression.SparseVoxelCompressor;
import com.hellblazer.luciferase.render.memory.GPUMemoryManager;
import com.hellblazer.luciferase.render.performance.RenderingProfiler;
import com.hellblazer.luciferase.render.rendering.VoxelRenderingPipeline;
import com.hellblazer.luciferase.render.testdata.TestDataGenerator;
import com.hellblazer.luciferase.render.voxel.VoxelRenderPipeline;
import com.hellblazer.luciferase.render.voxel.pipeline.MeshVoxelizer;
import com.hellblazer.luciferase.render.webgpu.WebGPURenderBridge;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.vecmath.Point3f;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;

/**
 * Interactive demonstration of the rendering pipeline capabilities.
 * Shows real-time performance metrics, visualization options, and system status.
 */
public class RenderingPipelineDemo {
    
    private static final Logger log = LoggerFactory.getLogger(RenderingPipelineDemo.class);
    
    private WebGPURenderBridge renderBridge;
    private VoxelRenderPipeline voxelPipeline;
    private VoxelRenderingPipeline renderingPipeline;
    private GPUMemoryManager memoryManager;
    private RenderingProfiler profiler;
    private boolean gpuAvailable = false;
    
    // Demo data
    private FloatBuffer cubeVertices;
    private FloatBuffer sphereVertices;
    private FloatBuffer bunnyVertices;
    private ByteBuffer voxelData;
    
    public static void main(String[] args) {
        var demo = new RenderingPipelineDemo();
        demo.run();
    }
    
    public void run() {
        log.info("=".repeat(80));
        log.info("LUCIFERASE RENDERING PIPELINE DEMONSTRATION");
        log.info("=".repeat(80));
        
        try {
            // Initialize systems
            initialize();
            
            // Run interactive demo
            runInteractiveDemo();
            
        } catch (Exception e) {
            log.error("Demo failed with error", e);
        } finally {
            // Cleanup
            shutdown();
        }
    }
    
    private void initialize() throws Exception {
        log.info("Initializing rendering systems...");
        
        // Initialize GPU systems
        renderBridge = new WebGPURenderBridge();
        var initFuture = renderBridge.initialize();
        gpuAvailable = initFuture.get(10, TimeUnit.SECONDS);
        
        if (gpuAvailable) {
            log.info("✓ GPU systems available - full pipeline enabled");
            
            voxelPipeline = new VoxelRenderPipeline(renderBridge);
            var pipelineInit = voxelPipeline.initialize();
            pipelineInit.get(5, TimeUnit.SECONDS);
            
            // Create configuration objects
            var renderConfig = new VoxelRenderingPipeline.RenderingConfiguration();
            var tempPath = java.nio.file.Files.createTempFile("voxel", ".tmp");
            var streamingIO = new com.hellblazer.luciferase.render.io.VoxelStreamingIO(tempPath);
            var compressor = new SparseVoxelCompressor();
            
            // Create WebGPU context for VoxelRenderingPipeline
            var webgpuContext = new com.hellblazer.luciferase.render.voxel.gpu.WebGPUContext();
            
            renderingPipeline = new VoxelRenderingPipeline(webgpuContext, streamingIO, compressor, renderConfig);
            renderingPipeline.initialize();
            
            var memConfig = new GPUMemoryManager.MemoryConfiguration();
            memoryManager = new GPUMemoryManager(webgpuContext, memConfig);
        } else {
            log.info("⚠ GPU not available - CPU-only mode");
        }
        
        // Initialize profiler
        profiler = new RenderingProfiler(memoryManager);
        
        // Generate demo data
        generateDemoData();
        
        log.info("System initialization complete");
        displaySystemStatus();
    }
    
    private void generateDemoData() {
        log.info("Generating demo data...");
        
        var generator = new TestDataGenerator();
        
        // Generate geometry
        // Generate simple test data
        cubeVertices = FloatBuffer.allocate(36 * 3); // 12 triangles * 3 vertices * 3 coords
        sphereVertices = FloatBuffer.allocate(1000 * 3);
        bunnyVertices = FloatBuffer.allocate(5000 * 3);
        
        // Fill with sample data
        for (int i = 0; i < cubeVertices.capacity(); i++) {
            cubeVertices.put((float) Math.random());
        }
        for (int i = 0; i < sphereVertices.capacity(); i++) {
            sphereVertices.put((float) Math.random());
        }
        for (int i = 0; i < bunnyVertices.capacity(); i++) {
            bunnyVertices.put((float) Math.random());
        }
        cubeVertices.flip();
        sphereVertices.flip();
        bunnyVertices.flip();
        
        // Generate voxel data
        voxelData = ByteBuffer.allocateDirect(128 * 128 * 128);
        for (int i = 0; i < voxelData.capacity(); i++) {
            voxelData.put((byte)(Math.random() * 256));
        }
        voxelData.flip();
        
        log.info("Demo data generated");
    }
    
    private void runInteractiveDemo() {
        var scanner = new Scanner(System.in);
        boolean running = true;
        
        while (running) {
            displayMenu();
            var choice = scanner.nextLine().trim();
            
            switch (choice) {
                case "1" -> demonstrateVoxelization();
                case "2" -> demonstrateCompression();
                case "3" -> demonstrateTextureCompression();
                case "4" -> demonstrateGPUMemory();
                case "5" -> demonstratePipeline();
                case "6" -> runPerformanceBenchmark();
                case "7" -> displaySystemStatus();
                case "8" -> generatePerformanceReport();
                case "q", "Q" -> running = false;
                default -> System.out.println("Invalid choice. Please try again.");
            }
        }
    }
    
    private void displayMenu() {
        System.out.println("\n=== RENDERING PIPELINE DEMO MENU ===");
        System.out.println("1. Demonstrate Voxelization");
        System.out.println("2. Demonstrate Sparse Voxel Compression");
        System.out.println("3. Demonstrate Texture Compression (DXT)");
        System.out.println("4. Demonstrate GPU Memory Management");
        System.out.println("5. Demonstrate Full Rendering Pipeline");
        System.out.println("6. Run Performance Benchmark");
        System.out.println("7. Display System Status");
        System.out.println("8. Generate Performance Report");
        System.out.println("Q. Quit");
        System.out.print("\nEnter choice: ");
    }
    
    private void demonstrateVoxelization() {
        log.info("\n=== VOXELIZATION DEMONSTRATION ===");
        
        if (!gpuAvailable) {
            log.warn("GPU not available - using CPU voxelization");
        }
        
        // Test different mesh complexities
        var meshSizes = new int[]{100, 1000, 10000};
        var resolutions = new int[]{32, 64, 128, 256};
        
        for (var meshSize : meshSizes) {
            log.info("\nTesting mesh with {} triangles:", meshSize);
            
            // Generate test mesh
            var generator = new TestDataGenerator();
            var vertices = FloatBuffer.allocate(meshSize * 9);
            for (int i = 0; i < vertices.capacity(); i++) {
                vertices.put((float) Math.random());
            }
            vertices.flip();
            
            for (var resolution : resolutions) {
                var frameProfiler = profiler.startFrame(System.nanoTime());
                frameProfiler.startPhase("Voxelization");
                
                var voxelizer = new MeshVoxelizer();
                var triangles = createTriangleList(vertices);
                var voxelizedData = voxelizer.voxelize(triangles, resolution);
                

                frameProfiler.endFrame();
                
                log.info("  Resolution {}³: {} voxels generated", 
                        resolution, voxelizedData.getActiveVoxelCount());
            }
        }
    }
    
    private void demonstrateCompression() {
        log.info("\n=== SPARSE VOXEL COMPRESSION DEMONSTRATION ===");
        
        var compressor = new SparseVoxelCompressor();
        var resolutions = new int[]{32, 64, 128};
        
        for (var resolution : resolutions) {
            log.info("\nTesting {}³ voxel grid:", resolution);
            
            // Generate test voxel data
            var testVoxels = ByteBuffer.allocateDirect(resolution * resolution * resolution);
            var generator = new TestDataGenerator();
            for (int i = 0; i < testVoxels.capacity(); i++) {
                testVoxels.put((byte)(Math.random() * 256));
            }
            testVoxels.flip();
            
            // Measure compression
            var frameProfiler = profiler.startFrame(System.nanoTime());
            frameProfiler.startPhase("Compression");
            
            long startTime = System.nanoTime();
            var octreeNode = createOctreeNode(testVoxels);
            var compressed = compressor.compress(octreeNode);
            long compressionTime = System.nanoTime() - startTime;
            
            frameProfiler.endPhase();
            frameProfiler.endFrame();
            
            var compressionRatio = (float)testVoxels.capacity() / compressed.remaining();
            log.info("  Original size: {} bytes", testVoxels.capacity());
            log.info("  Compressed size: {} bytes", compressed.remaining());
            log.info("  Compression ratio: {:.2f}:1", compressionRatio);
            log.info("  Compression time: {:.2f}ms", compressionTime / 1_000_000.0);
            
            // Test decompression
            startTime = System.nanoTime();
            var decompressed = compressor.decompress(compressed);
            long decompressionTime = System.nanoTime() - startTime;
            
            log.info("  Decompression time: {:.2f}ms", decompressionTime / 1_000_000.0);
        }
    }
    
    private void demonstrateTextureCompression() {
        log.info("\n=== TEXTURE COMPRESSION DEMONSTRATION ===");
        
        var compressor = new DXTCompressor();
        var textureSizes = new int[]{256, 512, 1024};
        
        for (var size : textureSizes) {
            log.info("\nTesting {}x{} texture:", size, size);
            
            // Generate test texture
            var textureData = ByteBuffer.allocateDirect(size * size * 4); // RGBA
            var generator = new TestDataGenerator();
            // Generate checkerboard pattern
            for (int y = 0; y < size; y++) {
                for (int x = 0; x < size; x++) {
                    boolean isWhite = ((x / 32) + (y / 32)) % 2 == 0;
                    byte color = isWhite ? (byte)255 : (byte)0;
                    textureData.put(color).put(color).put(color).put((byte)255);
                }
            }
            textureData.flip();
            
            // DXT1 Compression
            long startTime = System.nanoTime();
            var dxt1Compressed = compressor.compress(textureData, size, size, 
                                                    DXTCompressor.CompressionFormat.DXT1);
            long dxt1CompressTime = System.nanoTime() - startTime;
            
            log.info("  DXT1 Compression:");
            log.info("    Original: {} bytes", textureData.capacity());
            log.info("    Compressed: {} bytes", dxt1Compressed.remaining());
            log.info("    Ratio: {:.2f}:1", (float)textureData.capacity() / dxt1Compressed.remaining());
            log.info("    Time: {:.2f}ms", dxt1CompressTime / 1_000_000.0);
            
            // DXT1 Decompression
            startTime = System.nanoTime();
            var decompressed = compressor.decompress(dxt1Compressed, size, size,
                                                     DXTCompressor.CompressionFormat.DXT1);
            long dxt1DecompressTime = System.nanoTime() - startTime;
            log.info("    Decompression time: {:.2f}ms", dxt1DecompressTime / 1_000_000.0);
            
            // DXT5 Compression
            textureData.rewind();
            startTime = System.nanoTime();
            var dxt5Compressed = compressor.compress(textureData, size, size,
                                                    DXTCompressor.CompressionFormat.DXT5);
            long dxt5CompressTime = System.nanoTime() - startTime;
            
            log.info("  DXT5 Compression:");
            log.info("    Compressed: {} bytes", dxt5Compressed.remaining());
            log.info("    Ratio: {:.2f}:1", (float)textureData.capacity() / dxt5Compressed.remaining());
            log.info("    Time: {:.2f}ms", dxt5CompressTime / 1_000_000.0);
            
            // DXT5 Decompression
            startTime = System.nanoTime();
            decompressed = compressor.decompress(dxt5Compressed, size, size,
                                                DXTCompressor.CompressionFormat.DXT5);
            long dxt5DecompressTime = System.nanoTime() - startTime;
            log.info("    Decompression time: {:.2f}ms", dxt5DecompressTime / 1_000_000.0);
        }
    }
    
    private void demonstrateGPUMemory() {
        log.info("\n=== GPU MEMORY MANAGEMENT DEMONSTRATION ===");
        
        if (!gpuAvailable || memoryManager == null) {
            log.warn("GPU memory management not available");
            return;
        }
        
        // Test different buffer sizes
        var bufferSizes = new long[]{
            1024,           // 1KB
            1024 * 1024,    // 1MB
            16 * 1024 * 1024 // 16MB
        };
        
        for (var size : bufferSizes) {
            log.info("\nAllocating {} byte buffer:", size);
            
            long startTime = System.nanoTime();
            var bufferUsage = com.hellblazer.luciferase.render.voxel.gpu.WebGPUStubs.BufferUsage.VERTEX;
            var buffer = memoryManager.allocateBuffer(size, bufferUsage, "demo-buffer");
            long allocTime = System.nanoTime() - startTime;
            
            log.info("  Allocation time: {:.2f}ms", allocTime / 1_000_000.0);
            log.info("  Buffer allocated: {}", buffer != null);
            
            if (buffer != null) {
                // Test data upload
                var data = ByteBuffer.allocateDirect((int)Math.min(size, 1024 * 1024));
                startTime = System.nanoTime();
                memoryManager.uploadData(buffer, data);
                long uploadTime = System.nanoTime() - startTime;
                
                log.info("  Upload time: {:.2f}ms", uploadTime / 1_000_000.0);
                
                // Free buffer
                startTime = System.nanoTime();
                memoryManager.freeBuffer(buffer);
                long freeTime = System.nanoTime() - startTime;
                
                log.info("  Free time: {:.2f}ms", freeTime / 1_000_000.0);
            }
        }
        
        // Display memory statistics
        var stats = memoryManager.getMemoryStats();
        log.info("\nMemory Statistics:");
        log.info("  Total Allocated: {} bytes", stats.getAllocatedBytes());
        log.info("  Peak Usage: {} bytes", stats.getPeakUsage());
        log.info("  Active Buffers: {}", stats.getActiveBuffers());
        log.info("  Pool Hit Rate: {:.1f}%", stats.getPoolHitRate() * 100);
    }
    
    private void demonstratePipeline() {
        log.info("\n=== FULL RENDERING PIPELINE DEMONSTRATION ===");
        
        if (!gpuAvailable) {
            log.warn("GPU not available - limited demonstration");
            return;
        }
        
        try {
            // Process sphere mesh through complete pipeline
            log.info("Processing sphere mesh through pipeline...");
            
            var frameProfiler = profiler.startFrame(System.nanoTime());
            
            // Step 1: Voxelize
            frameProfiler.startPhase("Voxelization");
            var voxelizer = new MeshVoxelizer();
            var triangles = createTriangleList(sphereVertices);
            var voxelizedData = voxelizer.voxelize(triangles, 256);
            frameProfiler.endPhase();
            
            // Step 2: Compress
            frameProfiler.startPhase("Compression");
            var compressor = new SparseVoxelCompressor();
            voxelData.rewind();
            var octreeNode = createOctreeNode(voxelData);
            var compressed = compressor.compress(octreeNode);
            frameProfiler.endPhase();
            
            // Step 3: Upload to GPU
            if (voxelPipeline != null && voxelPipeline.isReady()) {
                frameProfiler.startPhase("GPU Upload");
                
                var pipeline = voxelPipeline;
                var buffer = pipeline.createBuffer(compressed.remaining());
                var indexBuffer = pipeline.createIndexBuffer(1024);
                
                var data = ByteBuffer.allocateDirect(compressed.remaining());
                data.put(compressed);
                data.flip();
                
                var indices = ByteBuffer.allocateDirect(1024);
                // Fill with sample indices
                for (int i = 0; i < 256; i++) {
                    indices.putInt(i);
                }
                indices.flip();
                
                var vertexUsage = com.hellblazer.luciferase.render.voxel.gpu.WebGPUStubs.BufferUsage.VERTEX;
                var indexUsage = com.hellblazer.luciferase.render.voxel.gpu.WebGPUStubs.BufferUsage.INDEX;
                pipeline.uploadBuffer(buffer, data, vertexUsage);
                pipeline.uploadBuffer(indexBuffer, indices, indexUsage);
                
                frameProfiler.endPhase();
                
                // Step 4: Render
                frameProfiler.startPhase("Rendering");
                var renderResult = pipeline.render();
                frameProfiler.endPhase();
                
                log.info("  Render result: {}", renderResult.get(1, TimeUnit.SECONDS));
            }
            
            frameProfiler.endFrame();
            
            // Display frame statistics
            var stats = profiler.getFrameStats();
            log.info("  Frame Times: avg={:.2f}ms", stats.getAverageFrameTime());
            
        } catch (Exception e) {
            log.error("Pipeline demonstration failed", e);
        }
    }
    
    private void runPerformanceBenchmark() {
        log.info("\n=== PERFORMANCE BENCHMARK ===");
        
        var iterations = 100;
        log.info("Running {} iterations...", iterations);
        
        for (int i = 0; i < iterations; i++) {
            var frameProfiler = profiler.startFrame(System.nanoTime());
            
            // Simulate workload
            frameProfiler.startPhase("Voxelization");
            try { Thread.sleep(5); } catch (InterruptedException e) {} // Simulate work
            frameProfiler.endPhase();
            
            frameProfiler.startPhase("Compression");
            try { Thread.sleep(3); } catch (InterruptedException e) {} // Simulate work
            frameProfiler.endPhase();
            
            frameProfiler.startPhase("GPU Upload");
            try { Thread.sleep(2); } catch (InterruptedException e) {} // Simulate work
            frameProfiler.endPhase();
            
            frameProfiler.startPhase("Rendering");
            try { Thread.sleep(10); } catch (InterruptedException e) {} // Simulate work
            frameProfiler.endPhase();
            
            frameProfiler.endFrame();
            
            if ((i + 1) % 10 == 0) {
                System.out.print(".");
            }
        }
        System.out.println();
        
        // Generate performance summary
        var frameStats = profiler.getFrameStats();
        var opStats = profiler.getOperationStats();
        
        log.info("\nBenchmark Results:");
        log.info("  Frames: {}", frameStats.getFrameCount());
        log.info("  Operations: {}", opStats.getOperationCount());
        log.info("  Avg FPS: {:.1f}", 1000.0 / frameStats.getAverageFrameTime());
        log.info("  Avg Frame Time: {:.2f}ms", frameStats.getAverageFrameTime());
        
        // Show per-operation statistics
        log.info("\nOperation Breakdown:");
        for (var entry : opStats.getOperationTimes().entrySet()) {
            var opName = entry.getKey();
            var times = entry.getValue();
            var avgTime = times.stream().mapToDouble(Double::doubleValue).average().orElse(0);
            log.info("  {}: {:.2f}ms avg", opName, avgTime);
        }
    }
    
    private void displaySystemStatus() {
        log.info("\n=== SYSTEM STATUS ===");
        
        // GPU Status
        log.info("GPU Systems:");
        log.info("  Available: {}", gpuAvailable ? "✓ Yes" : "✗ No");
        if (gpuAvailable) {
            log.info("  WebGPU Bridge: {}", renderBridge.isReady() ? "✓ Ready" : "✗ Not Ready");
            log.info("  Voxel Pipeline: {}", voxelPipeline.isReady() ? "✓ Ready" : "✗ Not Ready");
            log.info("  Rendering Pipeline: {}", renderingPipeline.isInitialized() ? "✓ Ready" : "✗ Not Ready");
            
            // Memory status
            if (memoryManager != null) {
                var stats = memoryManager.getMemoryStats();
                log.info("  GPU Memory: {} bytes allocated, {} active buffers", 
                        stats.getAllocatedBytes(), stats.getActiveBuffers());
            }
        }
        
        // Performance Status
        log.info("Performance Profiler:");
        var frameStats = profiler.getFrameStats();
        var opStats = profiler.getOperationStats();
        log.info("  Frames Recorded: {}", frameStats.getFrameCount());
        log.info("  Operations Recorded: {}", opStats.getOperationCount());
        if (frameStats.getFrameCount() > 0) {
            log.info("  Average Frame Time: {:.2f}ms", frameStats.getAverageFrameTime());
        }
        
        // System Resources
        var runtime = Runtime.getRuntime();
        var totalMemory = runtime.totalMemory() / 1024.0 / 1024.0;
        var freeMemory = runtime.freeMemory() / 1024.0 / 1024.0;
        var usedMemory = totalMemory - freeMemory;
        var maxMemory = runtime.maxMemory() / 1024.0 / 1024.0;
        
        log.info("JVM Memory:");
        log.info("  Used: {:.1f} MB", usedMemory);
        log.info("  Free: {:.1f} MB", freeMemory);
        log.info("  Total: {:.1f} MB", totalMemory);
        log.info("  Max: {:.1f} MB", maxMemory);
        log.info("  Usage: {:.1f}%", (usedMemory / maxMemory) * 100.0);
        
        // Test Data Status
        log.info("Test Data:");
        log.info("  Cube vertices: {} ({} triangles)", cubeVertices.remaining(), cubeVertices.remaining() / 9);
        log.info("  Sphere vertices: {} ({} triangles)", sphereVertices.remaining(), sphereVertices.remaining() / 9);
        log.info("  Bunny vertices: {} ({} triangles)", bunnyVertices.remaining(), bunnyVertices.remaining() / 9);
        log.info("  Voxel data: {} bytes (128³)", voxelData.remaining());
    }
    
    private void generatePerformanceReport() {
        log.info("\n=== PERFORMANCE REPORT ===");
        
        var report = profiler.generateReport();
        if (report != null) {
            log.info(report.getFormattedReport());
            
            var bottlenecks = profiler.detectBottlenecks();
            if (!bottlenecks.isEmpty()) {
                log.info("\nDetected Performance Bottlenecks:");
                for (var bottleneck : bottlenecks) {
                    log.info("  - {}", bottleneck);
                }
            }
        } else {
            log.info("No performance data available. Run some operations first.");
        }
    }
    
    private void shutdown() {
        log.info("Shutting down systems...");
        
        try {
            if (profiler != null) {
                profiler.shutdown();
            }
            if (memoryManager != null) {
                memoryManager.close();
            }
            if (renderingPipeline != null) {
                renderingPipeline.close();
            }
            if (voxelPipeline != null) {
                voxelPipeline.shutdown();
            }
            if (renderBridge != null) {
                renderBridge.shutdown();
            }
            
            log.info("System shutdown complete");
        } catch (Exception e) {
            log.error("Error during shutdown", e);
        }
    }
    
    // Helper methods
    private List<MeshVoxelizer.Triangle> createTriangleList(FloatBuffer vertices) {
        var triangles = new ArrayList<MeshVoxelizer.Triangle>();
        vertices.rewind();
        
        while (vertices.remaining() >= 9) {
            var v0 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            var v1 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            var v2 = new Point3f(vertices.get(), vertices.get(), vertices.get());
            triangles.add(new MeshVoxelizer.Triangle(v0, v1, v2, 0));
        }
        
        vertices.rewind();
        return triangles;
    }
    
    private SparseVoxelCompressor.OctreeNode createOctreeNode(ByteBuffer voxelData) {
        // Create a simple octree node for testing
        var node = new SparseVoxelCompressor.OctreeNode(
            SparseVoxelCompressor.NodeType.BRANCH, 0);
        node.level = 0;
        node.childMask = 0xFF; // All children present
        node.leafMask = 0x00;  // No leaves
        
        // Add some sample data
        voxelData.rewind();
        int sampleSize = Math.min(voxelData.remaining(), 256);
        node.data = new byte[sampleSize];
        voxelData.get(node.data);
        voxelData.rewind();
        
        return node;
    }
}