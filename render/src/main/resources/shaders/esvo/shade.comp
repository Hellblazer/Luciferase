#version 430 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Common structures
struct HitInfo {
    vec3 position;
    vec3 normal;
    vec4 color;
    float distance;
    uint nodeIndex;
    bool hit;
};

struct Light {
    vec3 position;
    vec3 direction;  // For directional lights
    vec3 color;
    float intensity;
    uint type;       // 0=point, 1=directional, 2=spot
    float range;     // For point/spot lights
    float spotAngle; // For spot lights
};

struct Material {
    vec4 albedo;
    vec3 emission;
    float metallic;
    float roughness;
    float ao;
    float ior;       // Index of refraction
};

// Buffers
layout(std430, binding = 0) readonly buffer HitBuffer {
    HitInfo hits[];
} hitBuffer;

layout(std430, binding = 1) writeonly buffer ColorBuffer {
    vec4 colors[];
} colorBuffer;

layout(std430, binding = 2) readonly buffer LightBuffer {
    Light lights[];
} lightBuffer;

layout(std430, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
} materialBuffer;

// Output image
layout(rgba32f, binding = 0) uniform image2D outputImage;

// Uniforms
uniform vec3 cameraPosition;
uniform vec3 ambientLight = vec3(0.1, 0.1, 0.1);
uniform uint lightCount;
uniform uint materialCount;
uniform float exposure = 1.0;
uniform float gamma = 2.2;

// Shader configuration
#ifdef ENABLE_PBR
    #define USE_PHYSICAL_BASED_RENDERING
#endif

#ifdef ENABLE_SHADOWS
    layout(std430, binding = 4) readonly buffer ShadowBuffer {
        float shadows[];
    } shadowBuffer;
#endif

#ifdef ENABLE_AO
    layout(std430, binding = 5) readonly buffer AOBuffer {
        float aoValues[];
    } aoBuffer;
#endif

// Mathematical constants
const float PI = 3.14159265359;
const float INV_PI = 1.0 / PI;

// Utility functions
vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float distributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

float geometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return num / denom;
}

float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = geometrySchlickGGX(NdotV, roughness);
    float ggx1 = geometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

vec3 calculateLighting(HitInfo hit, vec3 viewDir, Material material) {
    vec3 N = normalize(hit.normal);
    vec3 V = normalize(viewDir);
    vec3 albedo = material.albedo.rgb;
    
    // Calculate reflectance at normal incidence
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, material.metallic);
    
    vec3 Lo = vec3(0.0);
    
    // Calculate contribution from each light
    for (uint i = 0; i < lightCount; i++) {
        Light light = lightBuffer.lights[i];
        
        vec3 L;
        float attenuation = 1.0;
        
        if (light.type == 0u) {
            // Point light
            L = normalize(light.position - hit.position);
            float distance = length(light.position - hit.position);
            attenuation = 1.0 / (1.0 + 0.09 * distance + 0.032 * distance * distance);
            attenuation = min(attenuation, 1.0 / (distance * distance));
        } else if (light.type == 1u) {
            // Directional light
            L = normalize(-light.direction);
        } else if (light.type == 2u) {
            // Spot light
            L = normalize(light.position - hit.position);
            float distance = length(light.position - hit.position);
            float theta = dot(L, normalize(-light.direction));
            float epsilon = cos(light.spotAngle) - cos(light.spotAngle * 1.2);
            float intensity = clamp((theta - cos(light.spotAngle * 1.2)) / epsilon, 0.0, 1.0);
            attenuation = intensity / (1.0 + 0.09 * distance + 0.032 * distance * distance);
        }
        
        vec3 H = normalize(V + L);
        vec3 radiance = light.color * light.intensity * attenuation;
        
        #ifdef ENABLE_SHADOWS
            // Apply shadow attenuation
            float shadow = shadowBuffer.shadows[i];
            radiance *= (1.0 - shadow);
        #endif
        
        #ifdef USE_PHYSICAL_BASED_RENDERING
            // PBR calculation
            float NDF = distributionGGX(N, H, material.roughness);
            float G = geometrySmith(N, V, L, material.roughness);
            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
            
            vec3 kS = F;
            vec3 kD = vec3(1.0) - kS;
            kD *= 1.0 - material.metallic;
            
            vec3 numerator = NDF * G * F;
            float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
            vec3 specular = numerator / denominator;
            
            float NdotL = max(dot(N, L), 0.0);
            Lo += (kD * albedo * INV_PI + specular) * radiance * NdotL;
        #else
            // Simple Phong shading
            float NdotL = max(dot(N, L), 0.0);
            vec3 R = reflect(-L, N);
            float RdotV = max(dot(R, V), 0.0);
            
            vec3 diffuse = albedo * NdotL;
            vec3 specular = pow(RdotV, 32.0) * vec3(0.3);
            
            Lo += (diffuse + specular) * radiance;
        #endif
    }
    
    // Add ambient lighting
    vec3 ambient = ambientLight * albedo;
    
    #ifdef ENABLE_AO
        // Apply ambient occlusion
        float ao = aoBuffer.aoValues[gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * imageSize(outputImage).x];
        ambient *= ao;
    #else
        ambient *= material.ao;
    #endif
    
    vec3 color = ambient + Lo + material.emission;
    
    return color;
}

vec3 toneMapping(vec3 color) {
    // Exposure tone mapping
    vec3 mapped = vec3(1.0) - exp(-color * exposure);
    
    // Gamma correction
    mapped = pow(mapped, vec3(1.0 / gamma));
    
    return mapped;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    
    if (coord.x >= imageSize.x || coord.y >= imageSize.y) return;
    
    uint pixelIndex = coord.x + coord.y * imageSize.x;
    
    if (pixelIndex >= hitBuffer.hits.length()) return;
    
    HitInfo hit = hitBuffer.hits[pixelIndex];
    
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    
    if (hit.hit) {
        // Get material for this hit
        Material material;
        if (materialCount > 0 && hit.nodeIndex < materialCount) {
            material = materialBuffer.materials[hit.nodeIndex % materialCount];
        } else {
            // Default material
            material.albedo = hit.color;
            material.emission = vec3(0.0);
            material.metallic = 0.0;
            material.roughness = 0.8;
            material.ao = 1.0;
            material.ior = 1.5;
        }
        
        // Calculate view direction
        vec3 viewDir = cameraPosition - hit.position;
        
        // Calculate lighting
        vec3 litColor = calculateLighting(hit, viewDir, material);
        
        // Apply tone mapping
        litColor = toneMapping(litColor);
        
        finalColor = vec4(litColor, material.albedo.a);
    } else {
        // Background color or environment
        finalColor = vec4(0.05, 0.05, 0.1, 1.0); // Dark blue background
    }
    
    // Write to output buffers
    colorBuffer.colors[pixelIndex] = finalColor;
    imageStore(outputImage, coord, finalColor);
}