#version 460 core

// ESVO Ray Traversal Compute Shader
// Stack-based octree traversal for GPU ray tracing

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Node structure matching ESVONode (8 bytes)
struct Node {
    uint word0; // valid:8, leaf:8, far:1, pointer:15
    uint word1; // contour:8, contour_ptr:24
};

// Traversal stack entry
struct StackEntry {
    uint nodeIndex;     // Current node index
    uint childMask;     // Remaining children to visit
    float tMin;         // Entry distance
    float tMax;         // Exit distance
};

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 invDirection;  // Precomputed 1/direction for efficiency
};

// Constants
const uint STACK_SIZE = 23;  // Maximum tree depth
const uint INVALID_NODE = 0xFFFFFFFF;
const float EPSILON = 0.00001;

// Buffers
layout(std430, binding = 0) readonly buffer NodeBuffer {
    Node nodes[];
} nodeBuffer;

layout(std430, binding = 1) readonly buffer PageBuffer {
    uint pages[];  // Page data (8KB blocks)
} pageBuffer;

// Ray input/output
layout(binding = 2, rgba32f) uniform image2D rayOrigins;
layout(binding = 3, rgba32f) uniform image2D rayDirections;
layout(binding = 4, rgba32f) uniform image2D hitResults;

// Uniforms
uniform vec3 octreeMin;
uniform vec3 octreeMax;
uniform float octreeScale;
uniform uint rootNode;

// Shared memory for warp-level optimizations
shared uint sharedStack[gl_WorkGroupSize.x * gl_WorkGroupSize.y * STACK_SIZE];

// Get node from buffer
Node getNode(uint index) {
    return nodeBuffer.nodes[index];
}

// Extract fields from node
uint getValidMask(Node node) {
    return (node.word0 >> 24) & 0xFF;
}

uint getLeafMask(Node node) {
    return (node.word0 >> 16) & 0xFF;
}

bool hasFarPointer(Node node) {
    return ((node.word0 >> 15) & 0x1) != 0;
}

uint getChildPointer(Node node) {
    return node.word0 & 0x7FFF;
}

uint getContourMask(Node node) {
    return (node.word1 >> 24) & 0xFF;
}

// Ray-box intersection
bool intersectBox(vec3 boxMin, vec3 boxMax, Ray ray, out float tMin, out float tMax) {
    vec3 t0 = (boxMin - ray.origin) * ray.invDirection;
    vec3 t1 = (boxMax - ray.origin) * ray.invDirection;
    
    vec3 tSmall = min(t0, t1);
    vec3 tBig = max(t0, t1);
    
    tMin = max(max(tSmall.x, tSmall.y), tSmall.z);
    tMax = min(min(tBig.x, tBig.y), tBig.z);
    
    return tMin <= tMax && tMax >= 0.0;
}

// Get child bounds for octree subdivision
void getChildBounds(vec3 parentMin, vec3 parentMax, uint childIndex, 
                   out vec3 childMin, out vec3 childMax) {
    vec3 center = (parentMin + parentMax) * 0.5;
    
    childMin = mix(parentMin, center, vec3(
        (childIndex & 1) != 0,
        (childIndex & 2) != 0,
        (childIndex & 4) != 0
    ));
    
    childMax = mix(center, parentMax, vec3(
        (childIndex & 1) != 0,
        (childIndex & 2) != 0,
        (childIndex & 4) != 0
    ));
}

// Main traversal function
vec4 traverseOctree(Ray ray) {
    // Initialize stack
    uint stackPtr = 0;
    uint localStackBase = (gl_LocalInvocationIndex) * STACK_SIZE;
    
    // Check root intersection
    float rootTMin, rootTMax;
    if (!intersectBox(octreeMin, octreeMax, ray, rootTMin, rootTMax)) {
        return vec4(0.0); // No intersection
    }
    
    // Push root onto stack
    sharedStack[localStackBase + stackPtr] = rootNode;
    sharedStack[localStackBase + stackPtr + 1] = 0xFF; // All children
    sharedStack[localStackBase + stackPtr + 2] = floatBitsToUint(rootTMin);
    sharedStack[localStackBase + stackPtr + 3] = floatBitsToUint(rootTMax);
    stackPtr += 4;
    
    // Traversal loop
    vec4 result = vec4(0.0);
    float nearestHit = rootTMax;
    
    while (stackPtr > 0) {
        // Pop from stack
        stackPtr -= 4;
        uint nodeIndex = sharedStack[localStackBase + stackPtr];
        uint childMask = sharedStack[localStackBase + stackPtr + 1];
        float tMin = uintBitsToFloat(sharedStack[localStackBase + stackPtr + 2]);
        float tMax = uintBitsToFloat(sharedStack[localStackBase + stackPtr + 3]);
        
        // Skip if beyond nearest hit
        if (tMin > nearestHit) continue;
        
        // Get node data
        Node node = getNode(nodeIndex);
        uint validMask = getValidMask(node);
        uint leafMask = getLeafMask(node);
        
        // Process children in front-to-back order
        vec3 nodeMin = octreeMin; // TODO: Calculate actual node bounds
        vec3 nodeMax = octreeMax;
        
        for (int i = 0; i < 8; i++) {
            uint childBit = 1u << i;
            
            // Skip invalid or already processed children
            if ((validMask & childBit) == 0 || (childMask & childBit) == 0) {
                continue;
            }
            
            // Get child bounds
            vec3 childMin, childMax;
            getChildBounds(nodeMin, nodeMax, uint(i), childMin, childMax);
            
            // Test intersection
            float childTMin, childTMax;
            if (intersectBox(childMin, childMax, ray, childTMin, childTMax)) {
                if (childTMin <= nearestHit) {
                    if ((leafMask & childBit) != 0) {
                        // Leaf node - record hit
                        nearestHit = childTMin;
                        result = vec4(childMin, 1.0);
                    } else {
                        // Internal node - push to stack
                        uint childPtr = getChildPointer(node) + uint(i);
                        sharedStack[localStackBase + stackPtr] = childPtr;
                        sharedStack[localStackBase + stackPtr + 1] = 0xFF;
                        sharedStack[localStackBase + stackPtr + 2] = floatBitsToUint(childTMin);
                        sharedStack[localStackBase + stackPtr + 3] = floatBitsToUint(childTMax);
                        stackPtr += 4;
                    }
                }
            }
        }
    }
    
    return result;
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(rayOrigins);
    
    if (coord.x >= imageSize.x || coord.y >= imageSize.y) {
        return;
    }
    
    // Load ray data
    vec4 origin = imageLoad(rayOrigins, coord);
    vec4 direction = imageLoad(rayDirections, coord);
    
    // Prepare ray
    Ray ray;
    ray.origin = origin.xyz;
    ray.direction = normalize(direction.xyz);
    ray.invDirection = 1.0 / (ray.direction + vec3(EPSILON));
    
    // Traverse octree
    vec4 hitResult = traverseOctree(ray);
    
    // Store result
    imageStore(hitResults, coord, hitResult);
}