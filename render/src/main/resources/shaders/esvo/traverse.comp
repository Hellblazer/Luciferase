#version 430 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// ESVO Node structure matching Java ESVONode (8 bytes total)
// Packed as two 32-bit uints to match Java implementation
struct ESVONode {
    uint packedData1;     // validMask(8) | nonLeafMask(8) | farPointerFlag(1) | childPointer(15)
    uint packedData2;     // contourMask(8) | contourPointer(24)
};

// Ray structure for traversal
struct Ray {
    vec3 origin;
    vec3 direction;
    float tMin;
    float tMax;
    uint pixelX;
    uint pixelY;
};

// Intersection result
struct HitInfo {
    vec3 position;
    vec3 normal;
    vec4 color;
    float distance;
    uint nodeIndex;
    uint hit;            // Changed from bool to uint for SSBO compatibility
};

// Shader Storage Buffer Objects
layout(std430, binding = 0) readonly buffer NodeBuffer {
    ESVONode nodes[];
} nodeBuffer;

layout(std430, binding = 1) readonly buffer RayBuffer {
    Ray rays[];
} rayBuffer;

layout(std430, binding = 2) writeonly buffer ResultBuffer {
    HitInfo results[];
} resultBuffer;

layout(std430, binding = 3) readonly buffer PageBuffer {
    uint pages[];
} pageBuffer;

layout(std430, binding = 4) readonly buffer CountersBuffer {
    uint nodeCount;
    uint rayCount;
    uint pageCount;
    uint padding;
} counters;

// Uniforms
uniform mat4 worldToVoxel;
uniform vec3 voxelOrigin;
uniform float voxelSize;
uniform uint rootNodeIndex;

// Traversal stack for iterative traversal
#define MAX_STACK_DEPTH 23
struct StackEntry {
    uint nodeIndex;
    float tEnter;
    float tExit;
    vec3 cellMin;
    vec3 cellMax;
    uint level;
};

// Shader configuration macros
#ifdef ENABLE_SHADOWS
    #define EARLY_TERMINATION_THRESHOLD 0.99
#endif

#ifdef ENABLE_LOD
    uniform float lodBias;
    uniform float lodDistance;
#endif

#ifdef ENABLE_STATISTICS
    layout(std430, binding = 5) coherent buffer StatsBuffer {
        uint raysCast;
        uint nodesTraversed;
        uint leavesHit;
        uint stackOverflows;
    } stats;
#endif

// Utility functions

// Manual bit counting function (bitCount not available in GLSL 4.3)
uint popcount(uint x) {
    x = x - ((x >> 1) & 0x55555555u);
    x = (x & 0x33333333u) + ((x >> 2) & 0x33333333u);
    x = (x + (x >> 4)) & 0x0F0F0F0Fu;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x0000003Fu;
}

// Extract fields from packed node data
uint getValidMask(ESVONode node) {
    return (node.packedData1 >> 24) & 0xFFu;
}

uint getNonLeafMask(ESVONode node) {
    return (node.packedData1 >> 16) & 0xFFu;
}

uint getFarPointerFlag(ESVONode node) {
    return (node.packedData1 >> 15) & 0x1u;
}

uint getChildPointer(ESVONode node) {
    return node.packedData1 & 0x7FFFu;
}

uint getContourMask(ESVONode node) {
    return (node.packedData2 >> 24) & 0xFFu;
}

uint getContourPointer(ESVONode node) {
    return node.packedData2 & 0xFFFFFFu;
}

vec3 safe_inverse(vec3 v) {
    const float epsilon = 1e-6;
    const float large_val = 1e6;
    return vec3(
        abs(v.x) > epsilon ? 1.0 / v.x : large_val * sign(v.x),
        abs(v.y) > epsilon ? 1.0 / v.y : large_val * sign(v.y),
        abs(v.z) > epsilon ? 1.0 / v.z : large_val * sign(v.z)
    );
}

bool intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, out float tEnter, out float tExit) {
    vec3 invDir = safe_inverse(rayDir);
    vec3 t1 = (boxMin - rayOrigin) * invDir;
    vec3 t2 = (boxMax - rayOrigin) * invDir;
    
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    
    tEnter = max(max(tMin.x, tMin.y), tMin.z);
    tExit = min(min(tMax.x, tMax.y), tMax.z);
    
    return tEnter <= tExit && tExit > 0.0;
}

uint computeChildIndex(ESVONode node, uint octant) {
    uint validMask = getValidMask(node);
    uint childPointer = getChildPointer(node);
    uint farPointerFlag = getFarPointerFlag(node);
    
    // Count bits set before this octant to get child offset
    uint mask = validMask & ((1u << octant) - 1u);
    uint offset = popcount(mask);
    
    if (farPointerFlag != 0u) {
        // Far pointer - read from separate table
        uint pageIndex = childPointer + offset;
        if (pageIndex < counters.pageCount) {
            return pageBuffer.pages[pageIndex];
        } else {
            return 0u; // Invalid index
        }
    } else {
        // Direct pointer
        return childPointer + offset;
    }
}

vec3 computeChildMin(vec3 parentMin, vec3 parentMax, uint octant) {
    vec3 center = (parentMin + parentMax) * 0.5;
    return vec3(
        (octant & 1u) != 0u ? center.x : parentMin.x,
        (octant & 2u) != 0u ? center.y : parentMin.y,
        (octant & 4u) != 0u ? center.z : parentMin.z
    );
}

vec3 computeChildMax(vec3 parentMin, vec3 parentMax, uint octant) {
    vec3 center = (parentMin + parentMax) * 0.5;
    return vec3(
        (octant & 1u) != 0u ? parentMax.x : center.x,
        (octant & 2u) != 0u ? parentMax.y : center.y,
        (octant & 4u) != 0u ? parentMax.z : center.z
    );
}

uint getOctant(vec3 rayOrigin, vec3 rayDir, vec3 cellMin, vec3 cellMax, float t) {
    vec3 hitPoint = rayOrigin + rayDir * t;
    vec3 center = (cellMin + cellMax) * 0.5;
    
    uint octant = 0u;
    if (hitPoint.x >= center.x) octant |= 1u;
    if (hitPoint.y >= center.y) octant |= 2u;
    if (hitPoint.z >= center.z) octant |= 4u;
    
    return octant;
}

HitInfo processLeafNode(ESVONode node, Ray ray, vec3 cellMin, vec3 cellMax, float tEnter, uint nodeIndex) {
    HitInfo hit;
    hit.hit = 1u;
    hit.position = ray.origin + ray.direction * tEnter;
    hit.distance = tEnter;
    hit.nodeIndex = nodeIndex;
    
    // Compute normal based on which face was hit
    vec3 center = (cellMin + cellMax) * 0.5;
    vec3 hitLocal = hit.position - center;
    vec3 absHit = abs(hitLocal);
    
    // Determine which face was hit by finding the largest component
    if (absHit.x >= absHit.y && absHit.x >= absHit.z) {
        hit.normal = vec3(sign(hitLocal.x), 0.0, 0.0);
    } else if (absHit.y >= absHit.z) {
        hit.normal = vec3(0.0, sign(hitLocal.y), 0.0);
    } else {
        hit.normal = vec3(0.0, 0.0, sign(hitLocal.z));
    }
    
    // Basic color based on normal for now
    hit.color = vec4(hit.normal * 0.5 + 0.5, 1.0);
    
    return hit;
}

// Optimized octant ordering based on ray direction
void getOctantOrder(vec3 rayDir, out uint octantOrder[8]) {
    if (rayDir.x < 0.0) {
        if (rayDir.y < 0.0) {
            if (rayDir.z < 0.0) {
                // ---
                octantOrder[0] = 7u; octantOrder[1] = 6u; octantOrder[2] = 5u; octantOrder[3] = 4u;
                octantOrder[4] = 3u; octantOrder[5] = 2u; octantOrder[6] = 1u; octantOrder[7] = 0u;
            } else {
                // --+
                octantOrder[0] = 3u; octantOrder[1] = 2u; octantOrder[2] = 1u; octantOrder[3] = 0u;
                octantOrder[4] = 7u; octantOrder[5] = 6u; octantOrder[6] = 5u; octantOrder[7] = 4u;
            }
        } else {
            if (rayDir.z < 0.0) {
                // -+-
                octantOrder[0] = 5u; octantOrder[1] = 4u; octantOrder[2] = 7u; octantOrder[3] = 6u;
                octantOrder[4] = 1u; octantOrder[5] = 0u; octantOrder[6] = 3u; octantOrder[7] = 2u;
            } else {
                // -++
                octantOrder[0] = 1u; octantOrder[1] = 0u; octantOrder[2] = 3u; octantOrder[3] = 2u;
                octantOrder[4] = 5u; octantOrder[5] = 4u; octantOrder[6] = 7u; octantOrder[7] = 6u;
            }
        }
    } else {
        if (rayDir.y < 0.0) {
            if (rayDir.z < 0.0) {
                // +--
                octantOrder[0] = 6u; octantOrder[1] = 7u; octantOrder[2] = 4u; octantOrder[3] = 5u;
                octantOrder[4] = 2u; octantOrder[5] = 3u; octantOrder[6] = 0u; octantOrder[7] = 1u;
            } else {
                // +-+
                octantOrder[0] = 2u; octantOrder[1] = 3u; octantOrder[2] = 0u; octantOrder[3] = 1u;
                octantOrder[4] = 6u; octantOrder[5] = 7u; octantOrder[6] = 4u; octantOrder[7] = 5u;
            }
        } else {
            if (rayDir.z < 0.0) {
                // ++-
                octantOrder[0] = 4u; octantOrder[1] = 5u; octantOrder[2] = 6u; octantOrder[3] = 7u;
                octantOrder[4] = 0u; octantOrder[5] = 1u; octantOrder[6] = 2u; octantOrder[7] = 3u;
            } else {
                // +++
                octantOrder[0] = 0u; octantOrder[1] = 1u; octantOrder[2] = 2u; octantOrder[3] = 3u;
                octantOrder[4] = 4u; octantOrder[5] = 5u; octantOrder[6] = 6u; octantOrder[7] = 7u;
            }
        }
    }
}

void main() {
    uint rayIndex = gl_GlobalInvocationID.x;
    if (rayIndex >= counters.rayCount) return;
    
    Ray ray = rayBuffer.rays[rayIndex];
    
    // Initialize result
    HitInfo result;
    result.hit = 0u;
    result.distance = ray.tMax;
    result.position = vec3(0.0);
    result.normal = vec3(0.0);
    result.color = vec4(0.0);
    result.nodeIndex = 0u;
    
    // Stack-based iterative traversal
    StackEntry stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    
    // Initialize with root node
    vec3 rootMin = voxelOrigin;
    vec3 rootMax = voxelOrigin + vec3(voxelSize);
    
    float tEnter, tExit;
    if (!intersectAABB(ray.origin, ray.direction, rootMin, rootMax, tEnter, tExit)) {
        resultBuffer.results[rayIndex] = result;
        return;
    }
    
    tEnter = max(tEnter, ray.tMin);
    tExit = min(tExit, ray.tMax);
    
    if (tEnter >= tExit) {
        resultBuffer.results[rayIndex] = result;
        return;
    }
    
    // Validate root node index
    if (rootNodeIndex >= counters.nodeCount) {
        resultBuffer.results[rayIndex] = result;
        return;
    }
    
    // Push root node onto stack
    stack[stackPtr].nodeIndex = rootNodeIndex;
    stack[stackPtr].tEnter = tEnter;
    stack[stackPtr].tExit = tExit;
    stack[stackPtr].cellMin = rootMin;
    stack[stackPtr].cellMax = rootMax;
    stack[stackPtr].level = 0u;
    stackPtr++;
    
    #ifdef ENABLE_STATISTICS
        uint nodesTraversed = 0u;
    #endif
    
    // Get octant ordering for this ray direction
    uint octantOrder[8];
    getOctantOrder(ray.direction, octantOrder);
    
    while (stackPtr > 0) {
        StackEntry entry = stack[--stackPtr];
        
        // Validate node index
        if (entry.nodeIndex >= counters.nodeCount) continue;
        
        ESVONode node = nodeBuffer.nodes[entry.nodeIndex];
        
        #ifdef ENABLE_STATISTICS
            nodesTraversed++;
        #endif
        
        uint nonLeafMask = getNonLeafMask(node);
        
        // Check if this is a leaf node
        if (nonLeafMask == 0u) {
            // Process leaf
            result = processLeafNode(node, ray, entry.cellMin, entry.cellMax, entry.tEnter, entry.nodeIndex);
            
            #ifdef ENABLE_SHADOWS
                // Early termination for shadow rays
                break;
            #endif
            
            #ifdef ENABLE_STATISTICS
                atomicAdd(stats.leavesHit, 1u);
            #endif
            
            break;
        } else {
            // Process interior node
            uint validMask = getValidMask(node);
            
            // Traverse children in back-to-front order
            for (int i = 7; i >= 0; i--) {
                uint octant = octantOrder[i];
                
                // Check if child exists
                if ((validMask & (1u << octant)) == 0u) continue;
                
                // Compute child bounds
                vec3 childMin = computeChildMin(entry.cellMin, entry.cellMax, octant);
                vec3 childMax = computeChildMax(entry.cellMin, entry.cellMax, octant);
                
                // Test intersection with child
                float childTEnter, childTExit;
                if (!intersectAABB(ray.origin, ray.direction, childMin, childMax, childTEnter, childTExit)) {
                    continue;
                }
                
                childTEnter = max(childTEnter, entry.tEnter);
                childTExit = min(childTExit, entry.tExit);
                
                if (childTEnter >= childTExit) continue;
                
                #ifdef ENABLE_LOD
                    // LOD test - skip distant small nodes
                    float childSize = length(childMax - childMin);
                    float distance = childTEnter;
                    if (distance > lodDistance && childSize < lodBias / distance) {
                        continue;
                    }
                #endif
                
                // Get child node index
                uint childIndex = computeChildIndex(node, octant);
                if (childIndex == 0u || childIndex >= counters.nodeCount) continue;
                
                // Push child onto stack if there's room
                if (stackPtr < MAX_STACK_DEPTH) {
                    stack[stackPtr].nodeIndex = childIndex;
                    stack[stackPtr].tEnter = childTEnter;
                    stack[stackPtr].tExit = childTExit;
                    stack[stackPtr].cellMin = childMin;
                    stack[stackPtr].cellMax = childMax;
                    stack[stackPtr].level = entry.level + 1u;
                    stackPtr++;
                } else {
                    #ifdef ENABLE_STATISTICS
                        atomicAdd(stats.stackOverflows, 1u);
                    #endif
                }
            }
        }
    }
    
    #ifdef ENABLE_STATISTICS
        atomicAdd(stats.raysCast, 1u);
        atomicAdd(stats.nodesTraversed, nodesTraversed);
    #endif
    
    resultBuffer.results[rayIndex] = result;
}