package com.hellblazer.luciferase.webgpu.integration;

import com.hellblazer.luciferase.webgpu.WebGPU;
import com.hellblazer.luciferase.webgpu.ffm.WebGPUNative;
import com.hellblazer.luciferase.webgpu.surface.SurfaceDescriptor;
import com.hellblazer.luciferase.webgpu.wrapper.*;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.foreign.Arena;
import java.util.concurrent.TimeUnit;

/**
 * Simple triangle rendering demo using WebGPU and JavaFX.
 * Demonstrates the complete graphics pipeline from vertex data to screen presentation.
 */
public class TriangleDemo extends Application {
    private static final Logger log = LoggerFactory.getLogger(TriangleDemo.class);
    
    private Instance instance;
    private Adapter adapter;
    private Device device;
    private Surface surface;
    private RenderPipeline pipeline;
    private Buffer vertexBuffer;
    private Arena arena;
    
    // Vertex shader WGSL
    private static final String VERTEX_SHADER = """
        struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) color: vec3<f32>,
        };
        
        @vertex
        fn main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
            var output: VertexOutput;
            
            // Triangle vertices in clip space
            var positions = array<vec2<f32>, 3>(
                vec2<f32>( 0.0,  0.5),  // Top
                vec2<f32>(-0.5, -0.5),  // Bottom left
                vec2<f32>( 0.5, -0.5)   // Bottom right
            );
            
            // Vertex colors (RGB)
            var colors = array<vec3<f32>, 3>(
                vec3<f32>(1.0, 0.0, 0.0),  // Red
                vec3<f32>(0.0, 1.0, 0.0),  // Green
                vec3<f32>(0.0, 0.0, 1.0)   // Blue
            );
            
            output.position = vec4<f32>(positions[vertexIndex], 0.0, 1.0);
            output.color = colors[vertexIndex];
            
            return output;
        }
        """;
    
    // Fragment shader WGSL
    private static final String FRAGMENT_SHADER = """
        @fragment
        fn main(@location(0) color: vec3<f32>) -> @location(0) vec4<f32> {
            return vec4<f32>(color, 1.0);
        }
        """;
    
    @Override
    public void start(Stage primaryStage) {
        try {
            // Initialize WebGPU
            if (!WebGPU.initialize()) {
                log.error("Failed to initialize WebGPU");
                return;
            }
            
            arena = Arena.ofConfined();
            
            // Create WebGPU instance
            instance = new Instance();
            log.info("Created WebGPU instance");
            
            // Request adapter
            adapter = instance.requestAdapter().get(5, TimeUnit.SECONDS);
            if (adapter == null) {
                log.error("Failed to get adapter");
                return;
            }
            log.info("Got adapter");
            
            // Request device
            device = adapter.requestDevice().get(5, TimeUnit.SECONDS);
            if (device == null) {
                log.error("Failed to get device");
                return;
            }
            log.info("Got device");
            
            // Setup JavaFX window
            var root = new StackPane();
            var scene = new Scene(root, 800, 600);
            
            primaryStage.setTitle("WebGPU Triangle Demo");
            primaryStage.setScene(scene);
            primaryStage.show();
            
            // Create surface from JavaFX window
            try {
                var windowHandle = JavaFXIntegration.getNativeWindowHandle(primaryStage);
                var descriptor = SurfaceDescriptor.create(arena, windowHandle);
                surface = instance.createSurface(descriptor.getDescriptor());
                log.info("Created surface from JavaFX window");
            } catch (Exception e) {
                log.error("Failed to create surface", e);
                // Continue without surface for testing
            }
            
            // Create render pipeline
            setupRenderPipeline();
            
            // Create vertex buffer
            setupVertexBuffer();
            
            // Configure surface if available
            if (surface != null) {
                configureSurface();
            }
            
            // Start render loop
            startRenderLoop();
            
        } catch (Exception e) {
            log.error("Failed to initialize triangle demo", e);
        }
    }
    
    private void setupRenderPipeline() {
        log.info("Setting up render pipeline");
        
        // Create shader modules
        var vertexShader = device.createShaderModule(
            new Device.ShaderModuleDescriptor(VERTEX_SHADER)
                .withLabel("Triangle Vertex Shader")
        );
        
        var fragmentShader = device.createShaderModule(
            new Device.ShaderModuleDescriptor(FRAGMENT_SHADER)
                .withLabel("Triangle Fragment Shader")
        );
        
        // Create pipeline descriptor
        var descriptor = new RenderPipeline.RenderPipelineDescriptor();
        descriptor.label = "Triangle Pipeline";
        
        // Vertex state (no vertex buffers, using vertex index)
        descriptor.vertex = new RenderPipeline.VertexState(vertexShader)
            .withEntryPoint("main");
        
        // Fragment state
        descriptor.fragment = new RenderPipeline.FragmentState(fragmentShader)
            .withEntryPoint("main")
            .withTargets(new RenderPipeline.ColorTargetState(
                Texture.TextureFormat.BGRA8_UNORM
            ));
        
        // Primitive state
        descriptor.primitive = new RenderPipeline.PrimitiveState();
        descriptor.primitive.topology = RenderPipeline.PrimitiveTopology.TRIANGLE_LIST;
        descriptor.primitive.frontFace = RenderPipeline.FrontFace.CCW;
        descriptor.primitive.cullMode = RenderPipeline.CullMode.NONE;
        
        // Multisample state (no multisampling)
        descriptor.multisample = new RenderPipeline.MultisampleState();
        descriptor.multisample.count = 1;
        
        // Create the pipeline
        pipeline = device.createRenderPipeline(descriptor);
        log.info("Created render pipeline");
    }
    
    private void setupVertexBuffer() {
        log.info("Setting up vertex buffer");
        
        // Triangle vertices (x, y, r, g, b)
        float[] vertices = {
             0.0f,  0.5f,  1.0f, 0.0f, 0.0f,  // Top (red)
            -0.5f, -0.5f,  0.0f, 1.0f, 0.0f,  // Bottom left (green)
             0.5f, -0.5f,  0.0f, 0.0f, 1.0f   // Bottom right (blue)
        };
        
        // Create vertex buffer
        var bufferSize = vertices.length * Float.BYTES;
        vertexBuffer = device.createBuffer(
            new Device.BufferDescriptor(bufferSize, 
                WebGPUNative.BUFFER_USAGE_VERTEX | WebGPUNative.BUFFER_USAGE_COPY_DST)
                .withLabel("Triangle Vertex Buffer")
        );
        
        // Write vertex data to buffer
        var queue = device.getQueue();
        var data = new byte[bufferSize];
        var buffer = java.nio.ByteBuffer.wrap(data).order(java.nio.ByteOrder.nativeOrder());
        for (float v : vertices) {
            buffer.putFloat(v);
        }
        queue.writeBuffer(vertexBuffer, 0, data);
        
        log.info("Created vertex buffer with {} vertices", vertices.length / 5);
    }
    
    private void configureSurface() {
        if (surface == null) return;
        
        try {
            // Get preferred format
            var format = surface.getPreferredFormat(adapter);
            
            // Configure surface
            surface.configure(new Surface.Configuration.Builder()
                .withDevice(device)
                .withSize(800, 600)
                .withFormat(format)
                .withUsage(WebGPUNative.TEXTURE_USAGE_RENDER_ATTACHMENT)
                .withPresentMode(WebGPUNative.PRESENT_MODE_FIFO)
                .withAlphaMode(WebGPUNative.COMPOSITE_ALPHA_MODE_OPAQUE)
                .build()
            );
            
            log.info("Configured surface for presentation");
        } catch (Exception e) {
            log.error("Failed to configure surface", e);
        }
    }
    
    private void startRenderLoop() {
        log.info("Starting render loop");
        
        var animationTimer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                renderFrame();
            }
        };
        animationTimer.start();
    }
    
    private void renderFrame() {
        try {
            // Get current texture from surface
            Texture texture = null;
            if (surface != null) {
                var surfaceTexture = surface.getCurrentTexture();
                if (surfaceTexture != null && surfaceTexture.getStatus() == 0) {
                    texture = surfaceTexture.getTexture();
                }
            }
            
            // Create command encoder
            var encoder = device.createCommandEncoder("Frame Command Encoder");
            
            // Begin render pass
            var renderPass = encoder.beginRenderPass(
                new CommandEncoder.RenderPassDescriptor()
                    .withColorAttachment(0, new CommandEncoder.ColorAttachment()
                        .withView(texture != null ? texture.createView() : null)
                        .withLoadOp(CommandEncoder.LoadOp.CLEAR)
                        .withStoreOp(CommandEncoder.StoreOp.STORE)
                        .withClearValue(0.0, 0.0, 0.0, 1.0)  // Black background
                    )
            );
            
            // Set pipeline
            renderPass.setPipeline(pipeline);
            
            // Draw triangle (3 vertices, 1 instance)
            renderPass.draw(3, 1, 0, 0);
            
            // End render pass
            renderPass.end();
            
            // Finish command buffer
            var commandBuffer = encoder.finish("Frame Commands");
            
            // Submit to queue
            device.getQueue().submit(commandBuffer);
            
            // Present surface
            if (surface != null) {
                surface.present();
            }
            
        } catch (Exception e) {
            log.error("Error rendering frame", e);
        }
    }
    
    @Override
    public void stop() {
        log.info("Shutting down triangle demo");
        
        // Cleanup resources
        if (vertexBuffer != null) vertexBuffer.close();
        if (pipeline != null) pipeline.close();
        if (surface != null) surface.close();
        if (device != null) device.close();
        if (adapter != null) adapter.close();
        if (instance != null) instance.close();
        if (arena != null) arena.close();
        
        WebGPU.shutdown();
    }
    
    public static void main(String[] args) {
        launch(args);
    }
}