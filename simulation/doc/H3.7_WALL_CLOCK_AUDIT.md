# H3.7: Wall-Clock Audit & Conversion Plan

**Date**: 2026-01-12
**Bead**: Luciferase-xve9
**Total Production System.* Calls**: 120
**Breakdown**:
- Legitimate Clock abstraction: 7 calls (DO NOT CHANGE)
- Must convert: 113 calls

## Context

After completing H3.1-H3.5 (Clock foundation + 4 targeted files), 120 System.* calls remain in production code. This document provides a comprehensive audit and phased conversion strategy.

## DO NOT CHANGE (Legitimate Abstractions - 7 calls)

### Clock.java (4 calls)
- Line 52: `default long nanoTime() { return System.nanoTime(); }`
- Line 64, 69: `system()` factory method implementations
- **Reason**: Core Clock interface default implementations

### TestClock.java (3 calls)
- Line 158: `return System.currentTimeMillis() + offset.get();` (relative mode)
- Line 167: `return System.nanoTime() + nanoOffset.get();` (relative mode)
- **Reason**: Test clock relative mode implementations wrap System.* with offsets

---

## CRITICAL PRIORITY (Test-Affecting - ~35 calls)

These calls directly affect test determinism, message ordering, and state transitions.

### Migration & Distribution (20 calls)

**CrossProcessMigration.java (8 calls)**
- Lines 113, 222, 272: `startTime = System.currentTimeMillis()`
- Lines 177, 230, 280: `elapsed = System.currentTimeMillis() - startTime`
- Lines 138, 380: Message timestamp generation
- **Impact**: Migration latency measurement, message ordering, cross-process coordination

**RemoteBubbleProxy.java (6 calls)**
- Line 152: `new CacheEntry(value, System.currentTimeMillis() + cacheTTL)`
- Lines 181-182: `while (System.currentTimeMillis() - start < timeoutMs)`
- Lines 210-211: `while (System.currentTimeMillis() - start < timeoutMs)`
- Line 263: `System.currentTimeMillis() > expiresAt`
- **Impact**: Cache TTL determinism, timeout loop behavior

**MigrationProtocolMessages.java (6 calls)**
- Various message timestamp fields
- **Impact**: Message ordering, protocol determinism

### State Management (6 calls)

**GhostStateManager.java (4 calls)**
- Ghost creation/expiration timestamps
- **Impact**: Ghost lifecycle determinism

**EntityMigrationStateMachine.java (3 calls)**
- State transition timestamps
- **Impact**: State machine determinism, event ordering

### Network & Timing (9 calls)

**FakeNetworkChannel.java (5 calls)**
- Network delay simulation, message timestamps
- **Impact**: Network simulation determinism

**BucketSynchronizedController.java (2 calls)**
- Bucket synchronization timing
- **Impact**: Bucket-based time coordination

**VONDiscoveryProtocol.java (2 calls)**
- Discovery protocol timestamps
- **Impact**: VON topology discovery timing

---

## HIGH PRIORITY (Business Logic - ~25 calls)

These calls affect core simulation behavior but may not break tests immediately.

### Simulation Core (10 calls)
- **VonBubble.java (3)**: Bubble lifecycle, join/leave timestamps
- **MultiBubbleSimulation.java (2)**: Simulation start/stop timestamps
- **TwoBubbleSimulation.java (2)**: Dual-bubble coordination
- **SimulationLoop.java (2)**: Loop iteration timing
- **BubbleLifecycle.java (1)**: Lifecycle event timestamps

### Migration Tracking (11 calls)
- **MigrationTransaction.java (3)**: Transaction begin/commit/rollback timestamps
- **IdempotencyStore.java (3)**: Idempotency token expiration
- **MigrationCoordinator.java (1)**: Coordination timestamps
- **IdempotencyToken.java (1)**: Token generation timestamps
- **EntitySnapshot.java (1)**: Snapshot creation timestamps
- **MigrationLog.java (1)**: Migration log timestamps
- **MigrationMetrics.java (2)**: Migration performance metrics

### Process Management (4 calls)
- **ProcessMetadata.java (2)**: Process registration/heartbeat timestamps
- **ProcessRegistry.java (1)**: Registry update timestamps
- **ProcessCoordinator.java (1)**: Coordinator timestamps

---

## MEDIUM PRIORITY (Metrics & Monitoring - ~30 calls)

These calls are primarily for observability and don't affect behavioral determinism.

### Metrics Collection (18 calls)
- **ServerMetrics.java (4)**: Server performance metrics
- **DemoMetricsCollector.java (5)**: Demo scenario metrics
- **DistributedSimulationMetrics.java (2)**: Distributed metrics
- **MetricsSnapshot.java (1)**: Snapshot timestamps
- **ObservabilityMetrics.java (1)**: Observability data
- **GCPauseMeasurement.java (4)**: GC monitoring
- **InstrumentedGhostChannel.java (2)**: Channel instrumentation

### Integration & Validation (12 calls)
- **HybridBubbleController.java (2)**: Hybrid control timing
- **EntityMigrationLoadGenerator.java (2)**: Load generation timing
- **CrossProcessMigrationValidator.java (2)**: Validation timestamps
- **DistributedEntityFactory.java (2)**: Entity creation tracking
- **MessageOrderValidator.java (1)**: Message order validation
- **InjectableClock.java (1)**: Clock injection test
- **ConsensusMigrationIntegration.java (1)**: Integration metrics
- **OptimisticMigratorIntegration.java (1)**: Optimistic migration timing

---

## LOW PRIORITY (Debug & Logging - ~23 calls)

These calls are for debugging, visualization, and test infrastructure.

### Demo & Test Support (12 calls)
- **FailureScenario.java (2)**: Failure injection timing
- **FailureInjector.java (1)**: Injection timestamps
- **ExternalBubbleTracker.java (2)**: External bubble tracking
- **CrossProcessNeighborIndex.java (2)**: Neighbor indexing
- **grid/MultiBubbleSimulation.java (2)**: Grid-based simulation
- **EntityVisualizationServer.java (1)**: Visualization timestamps
- **GhostConsistencyValidator.java (1)**: Consistency validation
- **EventReprocessor.java (1)**: Event reprocessing

### Messaging (11 calls)
- **TopologyUpdateMessage.java (1)**: Topology change timestamps
- **RegisterProcessMessage.java (1)**: Registration timestamps
- **HeartbeatMessage.java (1)**: Heartbeat timestamps
- **GrpcBubbleNetworkChannel.java (2)**: gRPC timing
- **HeapMonitor.java (1)**: Heap monitoring

---

## Phased Conversion Strategy

### Phase 1: Critical Files (Days 1-2) - 35 calls in 6 files
**Goal**: Eliminate test-affecting wall-clock usage

1. **CrossProcessMigration.java** (8 calls) - Migration timing/ordering
2. **RemoteBubbleProxy.java** (6 calls) - Cache TTL/timeouts
3. **MigrationProtocolMessages.java** (6 calls) - Message timestamps
4. **GhostStateManager.java** (4 calls) - Ghost lifecycle
5. **EntityMigrationStateMachine.java** (3 calls) - State transitions
6. **FakeNetworkChannel.java** (5 calls) - Network simulation
7. **BucketSynchronizedController.java** (2 calls) - Bucket sync
8. **VONDiscoveryProtocol.java** (2 calls) - Discovery protocol

**Verification**: Run determinism tests after each file

### Phase 2: High Priority Files (Days 3-4) - 25 calls in 18 files
**Goal**: Convert core business logic

9-18. **Simulation Core** (10 calls): VonBubble, MultiBubbleSimulation, TwoBubbleSimulation, SimulationLoop, BubbleLifecycle
19-29. **Migration Tracking** (11 calls): MigrationTransaction, IdempotencyStore, MigrationCoordinator, etc.
30-33. **Process Management** (4 calls): ProcessMetadata, ProcessRegistry, ProcessCoordinator

**Verification**: Run full test suite after each subsystem

### Phase 3: Medium Priority Files (Days 5-6) - 30 calls in 18 files
**Goal**: Convert metrics and monitoring

34-51. **Metrics Collection** (18 calls): ServerMetrics, DemoMetricsCollector, etc.
52-63. **Integration & Validation** (12 calls): HybridBubbleController, EntityMigrationLoadGenerator, etc.

**Verification**: Spot-check test suite

### Phase 4: Low Priority Files (Day 7) - 23 calls in 19 files
**Goal**: Clean up debug/logging timestamps

64-75. **Demo & Test Support** (12 calls)
76-86. **Messaging** (11 calls)

**Verification**: Compilation check

---

## Implementation Pattern

For each file, follow this workflow:

```java
// 1. Add Clock import
import com.hellblazer.luciferase.simulation.distributed.integration.Clock;

// 2. Add Clock field with setter
private volatile Clock clock = Clock.system();

public void setClock(Clock clock) {
    this.clock = clock;
}

// 3. Replace System.* calls
// BEFORE: var now = System.currentTimeMillis();
// AFTER:  var now = clock.currentTimeMillis();

// BEFORE: var start = System.nanoTime();
// AFTER:  var start = clock.nanoTime();
```

**Testing workflow:**
1. Compile after changes
2. Run file-specific tests
3. For Critical/High priority: Run full test suite
4. Commit after verification
5. Push to CI every 3-5 files

---

## Progress Tracking

Use beads for each phase:
- `bd create --title="H3.7.1: Phase 1 Critical Files" --type=task`
- `bd create --title="H3.7.2: Phase 2 High Priority Files" --type=task`
- `bd create --title="H3.7.3: Phase 3 Medium Priority Files" --type=task`
- `bd create --title="H3.7.4: Phase 4 Low Priority Files" --type=task`

Mark dependencies: Each phase depends on the previous phase completing.

---

## Estimated Effort

- **Phase 1**: 8 files × 30 min = 4 hours (2 days with testing/CI)
- **Phase 2**: 18 files × 20 min = 6 hours (2 days with testing/CI)
- **Phase 3**: 18 files × 15 min = 4.5 hours (2 days with spot-checks)
- **Phase 4**: 19 files × 10 min = 3 hours (1 day, batch processing)

**Total**: 7 working days for systematic, careful conversion with full CI verification

---

## Success Criteria

- [ ] All 113 calls converted to Clock interface
- [ ] Zero System.currentTimeMillis() or System.nanoTime() in production code (except Clock.java, TestClock.java)
- [ ] All tests passing (including determinism tests)
- [ ] CI green for each phase
- [ ] No behavioral regressions detected
