# viz-render Streaming Subsystem: Architecture Redesign

**Date**: 2026-02-19
**Status**: Design complete — ready for implementation
**Use case**: Simulation debugger (1–5 developers, local or LAN)
**Bead**: Luciferase-uxbq

## Context

The existing viz-render subsystem (RegionStreamer, AdaptiveRegionManager, ViewportTracker) has good foundational ideas but critical integration failures: the camera tracking is broken (clientId never sent), dirty pinned regions never rebuild, and the streaming loop has no time budget. Rather than patch these individually, this document specifies the correct architecture from first principles.

**Protocol level cap**: The protocol normalizes all spatial keys to a single `long`. `CompactTetreeKey` uses 6 bits per level × up to 10 levels = 60 bits, fitting comfortably in one `long`. The protocol therefore caps TetreeKey at **level 10** — sufficient for all visualization use cases and consistent with the octree's Morton-code single-long encoding. `ExtendedTetreeKey` (levels 11–21, requiring two longs) is an internal tree implementation detail and is never exposed at the wire level.

---

## Section 1: Core Abstractions

### Cache Unit: `SpatialKey<?>`

The cache unit is `SpatialKey<?>` — the common superinterface of both `TetreeKey` (tetrahedral subdivision) and `MortonKey` (Morton-curve octree). This allows Java 24 pattern-matching dispatch without baking in tree type at the wrong level.

```java
// Example: compute LOD level from camera distance
// Coordinate space: internal integer space (0..2^21-1), cast to float for Point3f
double distanceToCenter = switch (key) {
    case TetreeKey<?> tk -> {
        var verts = Tet.tetrahedron(tk).coordinates();  // Point3i[4]
        float cx = (verts[0].x + verts[1].x + verts[2].x + verts[3].x) / 4.0f;
        float cy = (verts[0].y + verts[1].y + verts[2].y + verts[3].y) / 4.0f;
        float cz = (verts[0].z + verts[1].z + verts[2].z + verts[3].z) / 4.0f;
        yield Math.sqrt((cx - cam.x) * (cx - cam.x)
                      + (cy - cam.y) * (cy - cam.y)
                      + (cz - cam.z) * (cz - cam.z));
    }
    case MortonKey mk -> {
        var c = MortonCurve.decode(mk.getMortonCode());     // int[3]
        var len = Constants.lengthAtLevel(mk.getLevel());   // int
        float cx = c[0] + len / 2.0f;
        float cy = c[1] + len / 2.0f;
        float cz = c[2] + len / 2.0f;
        yield Math.sqrt((cx - cam.x) * (cx - cam.x)
                      + (cy - cam.y) * (cy - cam.y)
                      + (cz - cam.z) * (cz - cam.z));
    }
};
// LOD level (baseResolution = 1.0 at maxLevel, so log2(dist/1) = log2(dist))
int level = Math.max(minLevel, Math.min(maxLevel,
    (int) Math.floor(Math.log(distanceToCenter) / Math.log(2))));
```

**Important**: All coordinates are in internal integer space (0..2^21-1) cast to float — the same space used by `Tetree.insert(Point3f, ...)` and `Octree.insert(Point3f, ...)`. No worldSize scaling.

### Version Model

```java
// dirty ≡ keyVersion > cacheVersion
// Version 0L = "never dirtied / never built"
record CacheEntry(long version, byte[] content) {}

// DirtyTracker: ConcurrentHashMap<SpatialKey<?>, AtomicLong>
long version(SpatialKey<?> key) {
    var counter = keyVersions.get(key);
    return counter == null ? 0L : counter.get();
}
long bump(SpatialKey<?> key) {
    return keyVersions.computeIfAbsent(key, k -> new AtomicLong(0L))
                      .incrementAndGet();
}
```

Invariant at version 0: `0 > 0 = false`, so fresh keys are NOT dirty until first entity is placed.

### `SpatialIndexFacade` Interface

Owns entity positions and the spatial partition map. Replaces `AdaptiveRegionManager`.

```java
interface SpatialIndexFacade {
    // Entity lifecycle
    void put(EntityId id, Point3f position);
    void move(EntityId id, Point3f newPosition);
    void remove(EntityId id);

    // For DirtyTracker: all cells containing point at each level in [minLevel, maxLevel]
    Set<SpatialKey<?>> keysContaining(Point3f point, int minLevel, int maxLevel);

    // For RegionBuilder: entity positions in cell at build time (avoids TOCTOU)
    List<Point3f> positionsAt(SpatialKey<?> key);

    // For SubscriptionManager: cells intersecting frustum at given level
    Set<SpatialKey<?>> keysVisible(Frustum3D frustum, int level);

    // Inspection
    Set<SpatialKey<?>> allOccupiedKeys(int level);
    int entityCount();
}
```

**Internal state**:
- `ConcurrentHashMap<EntityId, Point3f> entityPositions`
- `ConcurrentHashMap<SpatialKey<?>, Set<EntityId>> cellOccupants`

**Two implementations**: `TetreeSpatialIndexFacade` (uses `Tet.locatePointBeyRefinementFromRoot`) and `OctreeSpatialIndexFacade` (uses `MortonKey.fromCoordinates`). Pattern-matched at the geometry boundary.

**`keysContaining` algorithm** (all levels L in [minLevel, maxLevel]):
```java
// Tetree path (per level L):
Tet t = Tet.locatePointBeyRefinementFromRoot(pos.x, pos.y, pos.z, (byte) L);
result.add(t.tmIndex());  // TetreeKey

// Octree path (per level L):
result.add(MortonKey.fromCoordinates((int) pos.x, (int) pos.y, (int) pos.z, (byte) L));
```
Bounded by `maxDirtyLevel` (default = `maxLodLevel`). Clamp out-of-bounds positions to [0, Constants.MAX_COORD].

**`keysVisible` algorithm** (O(N) over occupied keys at given level):
```java
Set<SpatialKey<?>> keysVisible(Frustum3D frustum, int level) {
    return cellOccupants.keySet().stream()
        .filter(k -> k.getLevel() == level)
        .filter(k -> frustumIntersects(k, frustum))
        .collect(Collectors.toUnmodifiableSet());
}

private boolean frustumIntersects(SpatialKey<?> key, Frustum3D frustum) {
    return switch (key) {
        case MortonKey mk -> {
            var c = MortonCurve.decode(mk.getMortonCode());     // int[]
            var s = (float) Constants.lengthAtLevel(mk.getLevel());
            yield frustum.intersectsAABB(c[0], c[1], c[2], c[0]+s, c[1]+s, c[2]+s);
        }
        case TetreeKey<?> tk -> {
            var v = Tet.tetrahedron(tk).coordinates();          // Point3i[4]
            float minX = v[0].x, maxX = v[0].x;
            float minY = v[0].y, maxY = v[0].y;
            float minZ = v[0].z, maxZ = v[0].z;
            for (var p : v) {
                minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
            }
            yield frustum.intersectsAABB(minX, minY, minZ, maxX, maxY, maxZ);
        }
    };
}
```

---

## Section 2: Protocol Contract

### Transport Interface

```java
interface Transport {
    void send(ServerMessage msg);
    void sendBinary(byte[] frame);
    Flux<ClientMessage> inbound();
    void close();
}
```

`InProcessTransport` (two `BlockingQueue`s) enables deterministic testing without WebSocket. Auth: `Authorization: Bearer <token>` header — never URL parameters. The server identifies the client from the WebSocket session; `clientId` is never in message payloads.

### Message Hierarchies

```java
sealed interface ClientMessage permits
    Hello, SnapshotRequest, Subscribe, ViewportUpdate, Unsubscribe {}

sealed interface ServerMessage permits
    HelloAck, SnapshotManifest, SnapshotFrame, RegionUpdate, RegionRemoved,
    SnapshotRequired, Error {}
```

### Phase C: Step / Pull

```
Client → Server: HELLO { version: "1.0" }
Server → Client: HELLO_ACK { sessionId }

Client → Server: SNAPSHOT_REQUEST { requestId, level, frustum? }
Server → Client: SNAPSHOT_MANIFEST { requestId, snapshotToken, regions: [RegionEntry] }
                  // RegionEntry: { key, snapshotVersion, dataSize }
Server → Client: [binary frames: one per region, tagged with snapshotToken]
```

**Snapshot atomicity**: `snapshotToken` is a monotonic `AtomicLong` incremented per `SUBSCRIBE`. Each `RegionEntry.snapshotVersion` is captured from `dirtyTracker.version(key)` at manifest compilation time — NOT the live version. Binary frames are sent after the manifest.

### Phase B: Push / Subscribe

```
Client → Server: SUBSCRIBE { snapshotToken, knownVersions: Map<keyString, version> }
Server → Client: [REGION_UPDATE | REGION_REMOVED | SNAPSHOT_REQUIRED, continuous push]

Client → Server: VIEWPORT_UPDATE { frustum, cameraPos, level }  // throttled, ≤1/100ms
Client → Server: UNSUBSCRIBE
```

**onSubscribe catchup** (closes Phase C→B gap): when `SUBSCRIBE` arrives:
```java
for (var entry : knownVersions.entrySet()) {
    var key = parseKey(entry.getKey());
    long currentVersion = dirtyTracker.version(key);
    if (currentVersion > entry.getValue()) {
        var cached = streamingCache.get(key);
        if (cached != null && cached.version() == currentVersion) {
            client.send(REGION_UPDATE(key, currentVersion, cached.content()));
        } else {
            buildQueue.submit(key, Priority.VISIBLE);
        }
    }
}
```

**`SNAPSHOT_REQUIRED`**: sent if server has evicted a key (no entities, no cache). Client removes that key from `knownVersions` and re-requests snapshot for it only.

### Binary Frame Header (24 bytes)

Both `MortonKey` and `CompactTetreeKey` (levels 0–10) fit in a single `long`. The protocol caps TetreeKey at level 10, so no `key_high` field is needed.

```
Offset  Size  Field        Values
0       4     magic        0x45535652 ('ESVR')
4       1     format       0x01=ESVO (octree), 0x02=ESVT (tetree)
5       1     key_type     0x01=Morton, 0x02=Tet (CompactTetreeKey, level 0-10)
6       1     level        0-10 (Tet), 0-21 (Morton — Morton supports deeper levels)
7       1     reserved     0x00
8       8     key          mortonCode (Morton); lowBits/tmIndex (Tet)
16      4     buildVersion monotonic version (truncated to int)
20      4     dataSize     payload byte count
Total: 24 bytes header + N bytes payload
```

Reconstruction on client:
- `key_type=0x01`: `new MortonKey(key, level)`
- `key_type=0x02`: `TetreeKey.create(level, key, 0L)` → always `CompactTetreeKey`

### JSON Key Wire Format

Both key types normalize to a single `long`. 64-bit values are base64-encoded in JSON (JS `Number.MAX_SAFE_INTEGER = 2^53-1` is insufficient for full 64-bit Morton codes or TetreeKey indices):

```json
{ "t": "tet", "l": 8, "i": "<base64>" }   // i = CompactTetreeKey.tmIndex (lowBits), level 0-10
{ "t": "oct", "l": 5, "i": "<base64>" }   // i = MortonKey.mortonCode, level 0-21
```

Server encoding: `Base64.getEncoder().encodeToString(ByteBuffer.allocate(8).putLong(keyLong).array())`.

Client `keyString()` (stable, bijective Map key): `{t}:{level}:{i}` — e.g. `tet:8:AAAAAAAAAGQ=`.

Client decode: `new DataView(base64ToArrayBuffer(i)).getBigInt64(0)`.

---

## Section 3: Test Infrastructure

### `InProcessSession`

```java
class InProcessSession {
    private final BlockingQueue<ClientMessage> fromClient = new LinkedBlockingQueue<>();
    private final BlockingQueue<ServerMessage> toClient   = new LinkedBlockingQueue<>();

    Transport serverTransport();    // server reads fromClient, writes toClient
    TestClientView clientView();    // test reads toClient, writes fromClient
}
```

No network, no serialization, deterministic. Enables synchronous test assertions:
```java
var session = new InProcessSession();
var view = session.clientView();
view.send(new Hello("1.0"));
var ack = view.nextMessage(HelloAck.class);
```

### `StreamingPipelineFixture`

Controls the full pipeline under test:
```java
class StreamingPipelineFixture {
    final SpatialIndexFacade world;
    final DirtyTracker dirtyTracker;
    final BuildQueue buildQueue;
    final StreamingCache cache;
    final SubscriptionManager subscriptions;

    void tick();                           // advance one streaming cycle
    void tick(long deadlineNanos);         // bounded tick
    List<ServerMessage> drainMessages();   // collect pushed messages
}
```

### `WorldFixture` Builder

```java
WorldFixture world = WorldFixture.tetree()
    .withEntities(100)
    .atLevel(8)
    .randomPositions(seed = 42L)
    .build();
// or:
WorldFixture.octree().withEntity(id, pos).build();
```

### Named Frustums

```java
class TestFrustums {
    static Frustum3D fullScene();      // encompasses entire world
    static Frustum3D origin();         // small frustum at origin
    static Frustum3D quadrant(int q);  // one of 8 octants
}
```

### `RecordingTransport`

```java
class RecordingTransport implements Transport {
    List<ServerMessage> sent();        // all sent messages in order
    List<byte[]> sentFrames();         // all sent binary frames
    void replay(TestClientView view);  // replay to client
}
```

`TestClock` (already exists in codebase) for deterministic time control.

---

## Section 4: Server Pipeline Lifecycle

### Components

```
Entity event
    ↓
SpatialIndexFacade          owns positions + partition map
    ↓ keysContaining(oldPos, newPos, minLevel, maxLevel)
DirtyTracker                ConcurrentHashMap<SpatialKey<?>, AtomicLong>
    ↓ version bump → submit
BuildQueue                  PriorityBlockingQueue + inFlight dedup map
    ↓ build
RegionBuilder               fetches positions from SpatialIndexFacade at build time
    ↓ onBuildComplete
StreamingCache              ConcurrentHashMap<SpatialKey<?>, CacheEntry>
    ↓
SubscriptionManager         per-client knownVersions, push delivery
```

**Central invariant**: `dirty ≡ dirtyTracker.version(key) > cacheVersion(key)`

### Build Deduplication

```java
ConcurrentHashMap<SpatialKey<?>, CompletableFuture<Void>> inFlight;

void submit(SpatialKey<?> key, Priority priority) {
    inFlight.computeIfAbsent(key, k -> {
        long expectedVersion = dirtyTracker.version(k);
        return executor.submit(() -> {
            var positions = facade.positionsAt(k);  // fetch at build time
            var content = regionBuilder.build(k, positions);
            onBuildComplete(k, expectedVersion, content);
        });
    });
}
```

Positions are fetched from `SpatialIndexFacade` at build time, not queue time — avoids TOCTOU.

### `onBuildComplete`

```java
void onBuildComplete(SpatialKey<?> key, long expectedVersion, byte[] content) {
    var counter = keyVersions.get(key);
    var current = (counter == null) ? 0L : counter.get();
    if (current != expectedVersion) {
        inFlight.remove(key);  // stale build — key was dirtied again
        return;
    }
    cache.put(key, new CacheEntry(expectedVersion, content));
    inFlight.remove(key);
    subscriptions.push(key, expectedVersion, content);  // deliver to subscribers
}
```

### Streaming Loop

```java
void streamingCycle(long deadlineNanos) {
    long start = System.nanoTime();
    var clientIds = subscriptions.activeClients();  // snapshot; ordered collection

    // Fair rotation: start from lastProcessedClient cursor
    var rotated = rotate(clientIds, lastProcessedClient);

    for (var clientId : rotated) {
        if (System.nanoTime() - start > deadlineNanos) break;  // time budget
        lastProcessedClient = clientId;

        var sub = subscriptions.get(clientId);
        var visible = facade.keysVisible(sub.frustum(), sub.level());
        var dirty = visible.stream()
            .filter(k -> dirtyTracker.version(k) > sub.knownVersion(k))
            .collect(toList());

        for (var key : dirty) {
            if (System.nanoTime() - start > deadlineNanos) break;
            var cached = cache.get(key);
            if (cached != null && cached.version() > sub.knownVersion(key)) {
                sub.send(new RegionUpdate(key, cached.version(), cached.content()));
                sub.setKnownVersion(key, cached.version());
            } else if (!inFlight.containsKey(key)) {
                buildQueue.submit(key, Priority.VISIBLE);
            }
        }
    }
}
```

**Fair rotation**: maintains `lastProcessedClient` cursor (index into `clients.valuesInOrder()`). Uses `CopyOnWriteArrayList<ClientId>` for the ordered subscription list — safe snapshot iteration, low write frequency (subscribe/unsubscribe), lock-free reads.

### Priority Enum

```java
enum Priority { VISIBLE, RECENTLY_VISIBLE, BACKFILL }
```

`VISIBLE`: keys in current viewport. `RECENTLY_VISIBLE`: keys seen in last N ticks. `BACKFILL`: pre-warming.

### `awaitBuilds()` (for test synchronization)

```java
CompletableFuture<Void> awaitBuilds() {
    var futures = new ArrayList<>(inFlight.values());
    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
}
```

Snapshot the `inFlight` map values at call time. Returns immediately if empty. Tests use: `fixture.awaitBuilds().get(5, SECONDS)`.

---

## Section 5: Client Architecture

### Layered Architecture (Mirror of Server)

```
Transport (WebSocket / InProcessTransport)
    ↓
ProtocolClient                    message framing, auth, reconnect
    ↓
SceneManager                      knownVersions map, scene graph
    ↓
VoxelRenderer (ESVO, existing)   rendering, onCameraChange event
```

### `Transport` Interface (JS)

```javascript
class Transport {
    send(msg) {}          // JSON control message
    sendBinary(buf) {}    // reserved (client doesn't send binary)
    onMessage(fn) {}      // fn(ClientMessage)
    onBinaryFrame(fn) {}  // fn(ArrayBuffer)
    close() {}
}

class WebSocketTransport extends Transport { /* ... */ }
class InProcessTransport extends Transport {
    // Two queues: serverToClient, clientToServer
    // Enables E2E tests without network
}
```

### `ProtocolClient`

```javascript
class ProtocolClient {
    constructor(transport) {}

    async connect() {}      // sends HELLO, awaits HELLO_ACK
    async requestSnapshot(level, frustum) {}  // SNAPSHOT_REQUEST → frames
    subscribe(knownVersions) {}               // SUBSCRIBE
    updateViewport(frustum, cameraPos, level) {}  // throttled ≤100ms

    onRegionUpdate(fn) {}    // fn(key, version, ArrayBuffer)
    onRegionRemoved(fn) {}   // fn(key)
    onSnapshotRequired(fn) {} // fn(key)
}
```

Auth: `Authorization: Bearer <token>` header in WebSocket upgrade request. Never URL params.

### `SceneManager`

```javascript
class SceneManager {
    constructor(protocolClient) {}

    // knownVersions: Map<keyString, version>
    // Scene graph: Map<keyString, SceneNode>

    onRegionUpdate(key, version, data) {
        var ks = keyString(key);
        var known = this.knownVersions.get(ks) ?? 0n;
        if (version <= known) return;          // version guard (BigInt compare)
        this.knownVersions.set(ks, version);
        this.renderer.put(ks, data);           // update ESVO scene
    }

    onRegionRemoved(key) {
        var ks = keyString(key);
        this.knownVersions.delete(ks);
        this.renderer.remove(ks);
    }
}
```

**`keyString(key)`** — stable, bijective Map key:
- Both types: `{t}:{level}:{i}` where `i` is the single base64-encoded `long`

### `VoxelRenderer` Extension

Add `onCameraChange` event (throttled):
```javascript
// Fired when camera moves, throttled to at most once per 100ms
renderer.onCameraChange = (frustum, cameraPos, level) => {
    protocolClient.updateViewport(frustum, cameraPos, level);
};
```

Level computation: `level = Math.max(minLevel, Math.min(maxLevel, Math.floor(Math.log2(distance))))` where `distance` is camera-to-scene-center in internal coordinate space.

---

## Known Pre-conditions for Implementation

The following bugs must be fixed during implementation (before or alongside the redesign):

| Bead | Fix |
|------|-----|
| Luciferase-2ocq | `MortonKey.equals()` must include `level` — audit `compareTo` for consistency first |
| Luciferase-sot7 | Binary frame header simplified to 24 bytes, single `key` long (see Section 2) |
| Luciferase-drnq | JSON key format: unified `{t,l,i}` with base64 single long (see Section 2) |
| Luciferase-9qkq | Section 1 geometry API calls corrected (see Section 1) |

---

## What This Design Does NOT Include

- Rate limiting / backpressure between clients (out of scope for debugger)
- Multi-server clustering or region handoff
- Client reconnection with full state recovery (re-subscribe from snapshot is sufficient)
- GPU acceleration (existing ESVO renderer handles this independently)

---

## P1 Spec Gaps (non-blocking, resolve during implementation)

| Bead | Topic |
|------|-------|
| Luciferase-5jis | Streaming loop rotation collection type (chosen above: `CopyOnWriteArrayList<ClientId>`) |
| Luciferase-255d | `awaitBuilds()` backing mechanism (specified above: snapshot `inFlight.values()`) |
| Luciferase-k7c7 | Correlation ID for `SNAPSHOT_REQUEST` (specified above: `requestId` field) |
| Luciferase-gq1q | LOD formula coordinate space (specified above: internal space, `log2(dist)`) |
| Luciferase-9404 | Which levels to dirty on entity move (specified above: all [minLevel, maxLevel]) |
